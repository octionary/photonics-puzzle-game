<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIGHTPATH — Photonic Systems Laboratory</title>
    <!-- Google Fonts: Orbitron for display, JetBrains Mono for code -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

    <style>
        /* ═══════════════════════════════════════════════════════════════════
           LIGHTPATH - RETRO-FUTURISTIC ENGINEERING INTERFACE
           Aesthetic: 1970s NASA Mission Control × CRT Oscilloscope × Blueprint
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Core palette - CRT phosphor inspired */
            --void: #050508;
            --abyss: #0a0a10;
            --deep: #0d0d14;
            --panel: #101018;
            --surface: #16161f;
            --raised: #1c1c28;

            /* Phosphor greens - primary */
            --phosphor: #00ff9f;
            --phosphor-dim: #00cc7f;
            --phosphor-glow: rgba(0, 255, 159, 0.4);
            --phosphor-subtle: rgba(0, 255, 159, 0.1);

            /* Amber - outputs/warnings */
            --amber: #ffaa00;
            --amber-dim: #cc8800;
            --amber-glow: rgba(255, 170, 0, 0.4);

            /* Cyan - optical elements */
            --cyan: #00d4ff;
            --cyan-dim: #00a8cc;
            --cyan-glow: rgba(0, 212, 255, 0.4);

            /* Coral/Red - errors/danger */
            --coral: #ff3366;
            --coral-dim: #cc2952;
            --coral-glow: rgba(255, 51, 102, 0.4);

            /* Electric violet - special accents */
            --violet: #aa66ff;
            --violet-glow: rgba(170, 102, 255, 0.3);

            /* Neutrals */
            --text-bright: #e8e8f0;
            --text-mid: #9090a0;
            --text-dim: #606070;
            --border: #252530;
            --border-bright: #3a3a48;
            --grid-line: #1a1a24;

            /* Functional */
            --success: var(--phosphor);
            --warning: var(--amber);
            --error: var(--coral);
            --info: var(--cyan);
        }

        /* ═══ BASE ═══════════════════════════════════════════════════════════ */

        body {
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            background: var(--void);
            color: var(--text-bright);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* CRT Scanline overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9999;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.15) 2px,
                rgba(0, 0, 0, 0.15) 4px
            );
        }

        /* Subtle noise texture */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        .app {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 6px;
            padding: 6px;
            background:
                radial-gradient(ellipse at 20% 0%, rgba(0, 255, 159, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(0, 212, 255, 0.02) 0%, transparent 50%),
                var(--void);
        }

        /* ═══ HEADER ═════════════════════════════════════════════════════════ */

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 1px solid var(--border);
            border-top: 2px solid var(--phosphor-dim);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                transparent,
                var(--phosphor) 20%,
                var(--phosphor) 80%,
                transparent
            );
            opacity: 0.6;
        }

        .header::after {
            content: '◆ PHOTONIC SYSTEMS LABORATORY ◆';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            font-weight: 500;
            letter-spacing: 0.3em;
            color: var(--text-dim);
            pointer-events: none;
        }

        .header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.6rem;
            font-weight: 800;
            letter-spacing: 0.15em;
            color: var(--phosphor);
            text-shadow:
                0 0 10px var(--phosphor-glow),
                0 0 30px var(--phosphor-glow),
                0 0 60px rgba(0, 255, 159, 0.2);
            position: relative;
        }

        .header h1::before {
            content: '';
            display: inline-block;
            width: 36px;
            height: 20px;
            margin-right: 12px;
            background: url('laser.svg') no-repeat center;
            background-size: contain;
            filter: brightness(0) saturate(100%) invert(82%) sepia(47%) saturate(1033%) hue-rotate(93deg) brightness(101%) contrast(104%)
                    drop-shadow(0 0 3px var(--phosphor))
                    drop-shadow(0 0 6px var(--phosphor))
                    drop-shadow(0 0 12px var(--phosphor-glow));
            animation: blink 2s step-end infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .level-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-mid);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .level-info span {
            padding: 4px 10px;
            background: var(--abyss);
            border: 1px solid var(--border);
            font-variant-numeric: tabular-nums;
        }

        /* ═══ MAIN LAYOUT ════════════════════════════════════════════════════ */

        .main-content {
            display: flex;
            gap: 0;
            overflow: hidden;
        }

        .resize-handle {
            width: 8px;
            background: linear-gradient(180deg,
                var(--border) 0%,
                var(--border-bright) 50%,
                var(--border) 100%
            );
            cursor: col-resize;
            transition: all 0.2s;
            position: relative;
        }

        .resize-handle::before {
            content: '⋮';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-dim);
            font-size: 1rem;
        }

        .resize-handle:hover {
            background: linear-gradient(180deg,
                var(--phosphor-dim) 0%,
                var(--phosphor) 50%,
                var(--phosphor-dim) 100%
            );
            box-shadow: 0 0 20px var(--phosphor-glow);
        }

        .resize-handle:hover::before {
            color: var(--void);
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
            overflow: hidden;
            flex: 1;
            padding: 0 6px 0 0;
        }

        .right-panel {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 6px;
            width: 450px;
            min-width: 320px;
            max-width: 700px;
            padding: 0 0 0 6px;
            overflow: hidden;
        }

        /* ═══ CANVAS AREA ════════════════════════════════════════════════════ */

        .canvas-container {
            background:
                linear-gradient(var(--grid-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-line) 1px, transparent 1px),
                radial-gradient(ellipse at center, var(--deep) 0%, var(--abyss) 100%);
            background-size: 50px 50px, 50px 50px, 100% 100%;
            border: 2px solid var(--border);
            border-top: 3px solid var(--cyan-dim);
            overflow: auto;
            position: relative;
            flex: 1;
            min-height: 200px;
            box-shadow:
                inset 0 0 100px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(0, 0, 0, 0.3);
        }

        .canvas-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .canvas-container::-webkit-scrollbar-track {
            background: var(--abyss);
        }

        .canvas-container::-webkit-scrollbar-thumb {
            background: var(--border-bright);
            border-radius: 2px;
        }

        .canvas-container::-webkit-scrollbar-thumb:hover {
            background: var(--cyan-dim);
        }

        .canvas-container::-webkit-scrollbar-corner {
            background: var(--abyss);
        }

        .canvas-container::before {
            content: 'DESIGN AREA';
            position: absolute;
            top: 8px;
            left: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.55rem;
            font-weight: 600;
            letter-spacing: 0.2em;
            color: var(--cyan-dim);
            opacity: 0.6;
            z-index: 10;
        }

        .canvas-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                transparent,
                var(--cyan) 30%,
                var(--cyan) 70%,
                transparent
            );
            opacity: 0.4;
        }

        #game-canvas {
            display: block;
        }

        .grid-cell {
            fill: transparent;
            stroke: var(--border);
            stroke-width: 0.5;
            transition: fill 0.15s;
        }

        .grid-cell:hover {
            fill: rgba(0, 212, 255, 0.08);
        }

        .grid-cell.valid-drop {
            fill: rgba(0, 255, 159, 0.15);
            animation: validPulse 0.8s ease-in-out infinite;
        }

        @keyframes validPulse {
            0%, 100% { fill: rgba(0, 255, 159, 0.1); }
            50% { fill: rgba(0, 255, 159, 0.2); }
        }

        /* ═══ COMPONENTS ═════════════════════════════════════════════════════ */

        .component {
            cursor: pointer;
            transition: filter 0.15s;
        }

        .component:hover {
            filter: brightness(1.3) drop-shadow(0 0 8px var(--cyan-glow));
        }

        .component.selected {
            filter: drop-shadow(0 0 12px var(--cyan)) drop-shadow(0 0 24px var(--cyan-glow));
        }

        .component.multi-selected {
            filter: drop-shadow(0 0 12px var(--phosphor)) drop-shadow(0 0 24px var(--phosphor-glow));
        }

        .selection-rect {
            fill: rgba(0, 212, 255, 0.1);
            stroke: var(--cyan);
            stroke-width: 1.5;
            stroke-dasharray: 6, 3;
            animation: marchingAnts 0.5s linear infinite;
        }

        @keyframes marchingAnts {
            to { stroke-dashoffset: -9; }
        }

        .component-body {
            fill: var(--surface);
            stroke: var(--cyan);
            stroke-width: 2;
        }

        .component-label {
            fill: var(--text-bright);
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }

        .port {
            fill: var(--cyan);
            stroke: var(--abyss);
            stroke-width: 2;
            cursor: crosshair;
            transition: all 0.15s;
        }

        .port:hover {
            fill: var(--phosphor);
            filter: drop-shadow(0 0 8px var(--phosphor-glow));
            r: 7;
        }

        .port.output {
            fill: var(--amber);
        }

        .port.output:hover {
            fill: #ffcc44;
            filter: drop-shadow(0 0 8px var(--amber-glow));
        }

        .port.electrical {
            fill: var(--violet);
            stroke: var(--abyss);
            stroke-width: 2;
        }

        .port.electrical.output {
            fill: var(--amber);
        }

        .port.electrical:hover {
            fill: #cc88ff;
            filter: drop-shadow(0 0 8px var(--violet-glow));
        }

        .connection {
            stroke: var(--cyan);
            stroke-width: 2.5;
            fill: none;
            opacity: 0.9;
            filter: drop-shadow(0 0 4px var(--cyan-glow));
        }

        .connection.active {
            stroke: var(--phosphor);
            filter: drop-shadow(0 0 8px var(--phosphor-glow));
            animation: signalFlow 1.5s ease-in-out infinite;
        }

        .connection.electrical {
            stroke: var(--violet);
            stroke-dasharray: 6, 4;
            filter: drop-shadow(0 0 4px var(--violet-glow));
        }

        @keyframes signalFlow {
            0%, 100% {
                opacity: 0.7;
                stroke-width: 2.5;
            }
            50% {
                opacity: 1;
                stroke-width: 3.5;
            }
        }

        .connection-preview {
            stroke: var(--cyan);
            stroke-width: 2;
            stroke-dasharray: 8, 6;
            fill: none;
            opacity: 0.5;
            animation: dashFlow 0.4s linear infinite;
        }

        @keyframes dashFlow {
            to { stroke-dashoffset: -14; }
        }

        /* ═══ COMPONENT PALETTE ══════════════════════════════════════════════ */

        .component-palette {
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 2px solid var(--border);
            border-left: 3px solid var(--amber-dim);
            padding: 12px 14px;
            flex-shrink: 0;
            position: relative;
        }

        .component-palette::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg,
                transparent,
                var(--amber) 30%,
                var(--amber) 70%,
                transparent
            );
            opacity: 0.5;
        }

        .palette-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            color: var(--amber);
            margin-bottom: 10px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .palette-title::before {
            content: '◈';
            font-size: 0.8rem;
        }

        .palette-items {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .palette-item {
            padding: 10px 14px;
            background:
                linear-gradient(180deg, var(--raised) 0%, var(--surface) 100%);
            border: 2px solid var(--border);
            border-bottom: 3px solid var(--border);
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 500;
            transition: all 0.15s;
            min-width: 70px;
            text-align: center;
            position: relative;
            color: var(--text-mid);
        }

        .palette-item::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
        }

        .palette-item:hover {
            border-color: var(--cyan);
            color: var(--cyan);
            background:
                linear-gradient(180deg, var(--surface) 0%, var(--raised) 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }

        .palette-item.selected {
            border-color: var(--phosphor);
            background:
                linear-gradient(180deg, rgba(0, 255, 159, 0.15) 0%, rgba(0, 255, 159, 0.05) 100%);
            color: var(--phosphor);
            box-shadow:
                0 0 20px var(--phosphor-glow),
                inset 0 0 20px rgba(0, 255, 159, 0.1);
        }

        .palette-item.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        /* ═══ CONTRACT PANEL ═════════════════════════════════════════════════ */

        .contract-panel {
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 2px solid var(--border);
            border-right: 3px solid var(--phosphor-dim);
            padding: 14px;
            flex-shrink: 0;
            max-height: 280px;
            overflow-y: auto;
            position: relative;
        }

        .contract-panel::before {
            content: 'CONTRACT BRIEF';
            position: absolute;
            top: 6px;
            right: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.5rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            color: var(--phosphor-dim);
            opacity: 0.6;
        }

        .contract-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            color: var(--phosphor);
            margin-bottom: 6px;
            text-shadow: 0 0 20px var(--phosphor-glow);
        }

        .contract-client {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 10px;
            padding-left: 10px;
            border-left: 2px solid var(--border);
        }

        .contract-description {
            font-size: 0.75rem;
            line-height: 1.6;
            color: var(--text-mid);
            margin-bottom: 14px;
        }

        .contract-objective {
            padding: 10px 12px;
            background:
                linear-gradient(90deg, rgba(0, 255, 159, 0.1) 0%, transparent 100%);
            border-left: 3px solid var(--phosphor);
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--phosphor);
            position: relative;
        }

        .contract-objective::before {
            content: 'TARGET';
            position: absolute;
            top: -8px;
            left: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.5rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: var(--phosphor-dim);
            background: var(--panel);
            padding: 0 4px;
        }

        /* ═══ SCRIPT EDITOR ══════════════════════════════════════════════════ */

        .script-panel {
            background: var(--abyss);
            border: 2px solid var(--border);
            border-bottom: 3px solid var(--violet);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-height: 150px;
            position: relative;
        }

        .script-header {
            padding: 8px 12px;
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border-bottom: 1px solid var(--border);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            color: var(--violet);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .script-header::before {
            content: '▣';
            font-size: 0.8rem;
        }

        #script-editor {
            flex: 1;
            background: var(--void);
            border: none;
            color: var(--text-bright);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.72rem;
            line-height: 1.6;
            padding: 12px;
            resize: none;
            outline: none;
            tab-size: 2;
        }

        #script-editor::selection {
            background: rgba(170, 102, 255, 0.3);
        }

        #script-editor:focus {
            box-shadow: inset 0 0 30px rgba(170, 102, 255, 0.05);
        }

        /* ═══ CONFIG PANEL ═══════════════════════════════════════════════════ */

        .config-panel {
            position: fixed;
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 2px solid var(--cyan);
            padding: 14px;
            min-width: 220px;
            z-index: 1000;
            display: none;
            box-shadow:
                0 0 30px var(--cyan-glow),
                0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .config-panel.visible {
            display: block;
            animation: panelAppear 0.2s ease-out;
        }

        @keyframes panelAppear {
            from {
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .config-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: var(--cyan);
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .config-close {
            cursor: pointer;
            color: var(--text-dim);
            font-size: 1.2rem;
            transition: color 0.15s;
            line-height: 1;
        }

        .config-close:hover {
            color: var(--coral);
            text-shadow: 0 0 10px var(--coral-glow);
        }

        .config-field {
            margin-bottom: 10px;
        }

        .config-field label {
            display: block;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.55rem;
            font-weight: 500;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .config-field input, .config-field select {
            width: 100%;
            padding: 8px 10px;
            background: var(--void);
            border: 1px solid var(--border);
            color: var(--text-bright);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            transition: all 0.15s;
        }

        .config-field input:focus, .config-field select:focus {
            border-color: var(--cyan);
            outline: none;
            box-shadow: 0 0 15px var(--cyan-glow);
        }

        .config-actions {
            display: flex;
            gap: 6px;
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        /* ═══ CONTROLS PANEL ═════════════════════════════════════════════════ */

        .controls-panel {
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 2px solid var(--border);
            padding: 12px 14px;
            flex-shrink: 0;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            transition: all 0.15s;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, transparent 100%);
            pointer-events: none;
        }

        .btn-primary {
            background:
                linear-gradient(180deg, var(--phosphor) 0%, var(--phosphor-dim) 100%);
            color: var(--void);
            border: 2px solid var(--phosphor);
            box-shadow:
                0 4px 0 var(--phosphor-dim),
                0 0 20px var(--phosphor-glow);
        }

        .btn-primary:hover {
            background:
                linear-gradient(180deg, #33ffb3 0%, var(--phosphor) 100%);
            transform: translateY(-2px);
            box-shadow:
                0 6px 0 var(--phosphor-dim),
                0 0 40px var(--phosphor-glow);
        }

        .btn-primary:active {
            transform: translateY(2px);
            box-shadow:
                0 2px 0 var(--phosphor-dim),
                0 0 20px var(--phosphor-glow);
        }

        .btn-secondary {
            background:
                linear-gradient(180deg, var(--raised) 0%, var(--surface) 100%);
            color: var(--text-mid);
            border: 2px solid var(--border);
            box-shadow: 0 4px 0 var(--abyss);
        }

        .btn-secondary:hover {
            border-color: var(--cyan);
            color: var(--cyan);
            box-shadow:
                0 4px 0 var(--abyss),
                0 0 20px var(--cyan-glow);
        }

        .btn-secondary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 var(--abyss);
        }

        .btn-danger {
            background:
                linear-gradient(180deg, var(--coral) 0%, var(--coral-dim) 100%);
            color: white;
            border: 2px solid var(--coral);
            box-shadow: 0 4px 0 var(--coral-dim);
        }

        .btn-danger:hover {
            background:
                linear-gradient(180deg, #ff5580 0%, var(--coral) 100%);
            box-shadow:
                0 4px 0 var(--coral-dim),
                0 0 20px var(--coral-glow);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
            transform: none !important;
            box-shadow: none !important;
        }

        /* ═══ RESULTS PANEL ══════════════════════════════════════════════════ */

        .results-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(5, 5, 8, 0.85);
            backdrop-filter: blur(4px);
            z-index: 299;
            display: none;
        }

        .results-overlay.visible {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .results-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 2px solid var(--cyan);
            padding: 24px;
            display: none;
            z-index: 300;
            min-width: 440px;
            max-width: 640px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow:
                0 0 60px var(--cyan-glow),
                0 20px 60px rgba(0, 0, 0, 0.6);
        }

        .results-panel.visible {
            display: block;
            animation: modalAppear 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .results-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        .results-title.pass {
            color: var(--phosphor);
            text-shadow: 0 0 20px var(--phosphor-glow);
        }

        .results-title.pass::before {
            content: '✓ ';
        }

        .results-title.fail {
            color: var(--coral);
            text-shadow: 0 0 20px var(--coral-glow);
        }

        .results-title.fail::before {
            content: '✗ ';
        }

        .results-close {
            cursor: pointer;
            color: var(--text-dim);
            font-size: 1.5rem;
            transition: all 0.15s;
            line-height: 1;
        }

        .results-close:hover {
            color: var(--coral);
            text-shadow: 0 0 10px var(--coral-glow);
        }

        .test-case {
            margin-bottom: 12px;
            padding: 12px;
            background: var(--abyss);
            border: 1px solid var(--border);
            position: relative;
        }

        .test-case::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--border);
        }

        .test-case:has(.test-case-status.pass)::before {
            background: var(--phosphor);
        }

        .test-case:has(.test-case-status.fail)::before {
            background: var(--coral);
        }

        .test-case-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .test-case-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-bright);
        }

        .test-case-status {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        .test-case-status.pass {
            color: var(--phosphor);
        }

        .test-case-status.fail {
            color: var(--coral);
        }

        .test-case-details {
            font-size: 0.7rem;
            color: var(--text-dim);
            font-variant-numeric: tabular-nums;
        }

        .expected-value {
            color: var(--text-dim);
        }

        .actual-value {
            color: var(--text-bright);
            font-weight: 500;
        }

        .actual-value.pass {
            color: var(--phosphor);
        }

        .actual-value.fail {
            color: var(--coral);
        }

        .score-display {
            display: flex;
            gap: 24px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .score-item {
            text-align: center;
            flex: 1;
            padding: 12px;
            background: var(--abyss);
            border: 1px solid var(--border);
        }

        .score-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.55rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            color: var(--text-dim);
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        .score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--cyan);
            text-shadow: 0 0 15px var(--cyan-glow);
        }

        .console-output {
            margin-top: 16px;
            padding: 12px;
            background: var(--void);
            border: 1px solid var(--border);
            font-size: 0.7rem;
            max-height: 120px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
        }

        .console-line {
            color: var(--text-dim);
            margin-bottom: 3px;
            padding-left: 12px;
            position: relative;
        }

        .console-line::before {
            content: '›';
            position: absolute;
            left: 0;
            color: var(--text-dim);
        }

        .console-line.error {
            color: var(--coral);
        }

        .console-line.error::before {
            content: '!';
            color: var(--coral);
        }

        /* ═══ PLOT ═══════════════════════════════════════════════════════════ */

        .plot-container {
            margin-top: 16px;
            padding: 16px;
            background: var(--abyss);
            border: 1px solid var(--border);
        }

        .plot-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            margin-bottom: 12px;
            text-align: center;
            text-transform: uppercase;
        }

        .plot-svg {
            background: var(--void);
            border: 1px solid var(--border);
        }

        .plot-axis-label {
            font-size: 10px;
            fill: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        .plot-line {
            fill: none;
            stroke: var(--cyan);
            stroke-width: 2;
            filter: drop-shadow(0 0 4px var(--cyan-glow));
        }

        .plot-grid-line {
            stroke: var(--border);
            stroke-width: 0.5;
        }

        .plot-axis {
            stroke: var(--text-dim);
            stroke-width: 1;
        }

        /* ═══ FOOTER ═════════════════════════════════════════════════════════ */

        .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 1px solid var(--border);
            border-bottom: 2px solid var(--border-bright);
            font-size: 0.65rem;
            color: var(--text-dim);
            position: relative;
        }

        .footer > div {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: var(--abyss);
            border: 1px solid var(--border);
        }

        .footer span {
            color: var(--cyan);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        #status-text {
            color: var(--phosphor);
        }

        /* ═══ MODAL ══════════════════════════════════════════════════════════ */

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(5, 5, 8, 0.9);
            backdrop-filter: blur(6px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background:
                linear-gradient(180deg, var(--panel) 0%, var(--deep) 100%);
            border: 2px solid var(--cyan);
            padding: 28px;
            min-width: 440px;
            max-width: 640px;
            box-shadow:
                0 0 60px var(--cyan-glow),
                0 20px 60px rgba(0, 0, 0, 0.6);
            animation: modalAppear 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            color: var(--phosphor);
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--phosphor-glow);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-title::before {
            content: '◆';
            font-size: 0.8rem;
        }

        .puzzle-list {
            display: grid;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .puzzle-item {
            padding: 14px 16px;
            background: var(--abyss);
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .puzzle-item:hover {
            border-color: var(--cyan);
            background: rgba(0, 212, 255, 0.05);
            transform: translateX(4px);
        }

        .puzzle-item.completed {
            border-left: 4px solid var(--phosphor);
        }

        .puzzle-item.completed::after {
            content: '✓';
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--phosphor);
            font-weight: bold;
        }

        .puzzle-item.current {
            border-color: var(--cyan);
            background: rgba(0, 212, 255, 0.1);
            box-shadow: 0 0 20px var(--cyan-glow);
        }

        .puzzle-item-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-bright);
            margin-bottom: 4px;
        }

        .puzzle-item-arc {
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        /* ═══ HINTS ══════════════════════════════════════════════════════════ */

        .hints-section {
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid var(--border);
        }

        .hints-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: var(--amber);
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.15s;
        }

        .hints-title::before {
            content: '▶';
            font-size: 0.5rem;
            transition: transform 0.2s;
        }

        .hints-title:hover {
            color: var(--amber);
            text-shadow: 0 0 10px var(--amber-glow);
        }

        .hints-list {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .hints-list.hidden {
            display: none;
        }

        .hints-list:not(.hidden) + .hints-title::before,
        .hints-section:has(.hints-list:not(.hidden)) .hints-title::before {
            transform: rotate(90deg);
        }

        .hint-item {
            margin-bottom: 6px;
            padding: 8px 12px;
            background: var(--abyss);
            border-left: 2px solid var(--amber-dim);
            color: var(--text-mid);
        }

        /* ═══ SCROLLBAR ══════════════════════════════════════════════════════ */

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--abyss);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-bright);
            border: 1px solid var(--border);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        /* ═══ SELECTION ══════════════════════════════════════════════════════ */

        ::selection {
            background: rgba(0, 212, 255, 0.3);
            color: var(--text-bright);
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <h1>LIGHTPATH</h1>
            <div class="level-info">
                <span id="arc-name">Arc 1: Basics</span>
                <span id="puzzle-progress">Puzzle 1/6</span>
                <button class="btn btn-secondary" onclick="showPuzzleSelector()">Select Puzzle</button>
            </div>
        </header>

        <main class="main-content">
            <div class="left-panel">
                <div class="canvas-container">
                    <svg id="game-canvas"></svg>
                    <div id="config-panel" class="config-panel">
                        <div class="config-title">
                            <span id="config-component-name">Component</span>
                            <span class="config-close" onclick="closeConfigPanel()">&times;</span>
                        </div>
                        <div id="config-fields"></div>
                        <div class="config-actions">
                            <button class="btn btn-primary" onclick="closeConfigPanel()">Apply</button>
                            <button class="btn btn-danger" onclick="deleteSelectedComponent()">Delete</button>
                        </div>
                    </div>
                </div>

                <div class="component-palette">
                    <div class="palette-title">Components — click to select, then click grid to place</div>
                    <div id="palette-items" class="palette-items"></div>
                </div>
            </div>

            <div class="resize-handle" id="resize-handle"></div>

            <div class="right-panel" id="right-panel">
                <div class="contract-panel">
                    <div id="contract-title" class="contract-title">Hello Photon</div>
                    <div id="contract-client" class="contract-client">Client: Lightpath Training</div>
                    <div id="contract-description" class="contract-description">
                        Welcome to your first day at Lightpath! Let's start simple: connect a laser to a detector and measure the output power.
                    </div>
                    <div id="contract-objective" class="contract-objective">
                        Measure 0 dBm ± 0.5 dB at the detector
                    </div>
                    <div class="hints-section">
                        <div class="hints-title" onclick="toggleHints()">Hints (click to show)</div>
                        <div id="hints-list" class="hints-list hidden"></div>
                    </div>
                </div>

                <div class="script-panel">
                    <div class="script-header">SCRIPT EDITOR</div>
                    <textarea id="script-editor" spellcheck="false"></textarea>
                </div>

                <div class="controls-panel">
                    <div class="control-buttons">
                        <button id="run-btn" class="btn btn-primary" onclick="runSimulation()">&#9654; EXECUTE</button>
                        <button class="btn btn-secondary" onclick="resetCircuit()">&#8635; RESET</button>
                    </div>
                </div>
            </div>
        </main>

        <footer class="footer">
            <div>Components: <span id="component-count">0</span></div>
            <div>Waveguides: <span id="connection-count">0</span></div>
            <div id="status-text">Ready</div>
        </footer>
    </div>

    <!-- Results overlay -->
    <div id="results-overlay" class="results-overlay" onclick="closeResults()"></div>
    <div id="results-panel" class="results-panel">
        <div class="results-header">
            <div id="results-title" class="results-title">TEST RESULTS</div>
            <span class="results-close" onclick="closeResults()">&times;</span>
        </div>
        <div id="results-content"></div>
        <div id="plot-container" class="plot-container" style="display: none;"></div>
        <div id="console-output" class="console-output"></div>
        <div class="score-display">
            <div class="score-item">
                <div class="score-label">Components</div>
                <div id="score-components" class="score-value">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">Waveguides</div>
                <div id="score-connections" class="score-value">0</div>
            </div>
        </div>
        <div style="margin-top: 16px; text-align: center;">
            <button id="next-puzzle-btn" class="btn btn-primary" onclick="nextPuzzle()" style="display: none;">Next Puzzle →</button>
        </div>
    </div>

    <!-- Puzzle selector modal -->
    <div id="puzzle-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-title">Select Puzzle</div>
            <div id="puzzle-list" class="puzzle-list"></div>
            <div style="margin-top: 16px; text-align: right;">
                <button class="btn btn-secondary" onclick="hidePuzzleSelector()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // GAME STATE
        // ============================================
        const GameState = {
            components: [],
            connections: [],
            selectedComponent: null,
            selectedPaletteItem: null,
            connectingFrom: null,
            currentPuzzleIndex: 0,
            completedPuzzles: new Set(),
            gridSize: { cols: 20, rows: 12 },
            cellSize: 50,
            dragging: null, // { componentId, startX, startY, offsetX, offsetY }
            paletteDragging: null, // { type, startX, startY } for drag from palette
            selectedComponents: new Set(), // Multi-selection
            boxSelect: null, // { startX, startY, currentX, currentY } for box selection
            multiDrag: null, // { startX, startY, offsets: Map } for dragging multiple components
            waveguideSegments: [], // cached rectilinear paths for rendering
            undoStack: [],
            redoStack: [],
            maxUndoSteps: 50,
            connectionDragging: null // { componentId, port, portDef, startX, startY } for drag-to-connect
        };

        // ============================================
        // UNDO/REDO SYSTEM
        // ============================================
        function saveState() {
            // Deep clone components and connections
            const state = {
                components: JSON.parse(JSON.stringify(GameState.components)),
                connections: JSON.parse(JSON.stringify(GameState.connections))
            };
            GameState.undoStack.push(state);
            if (GameState.undoStack.length > GameState.maxUndoSteps) {
                GameState.undoStack.shift();
            }
            // Clear redo stack on new action
            GameState.redoStack = [];
        }

        function undo() {
            if (GameState.undoStack.length === 0) {
                updateStatus('Nothing to undo');
                return;
            }
            // Save current state to redo stack
            const currentState = {
                components: JSON.parse(JSON.stringify(GameState.components)),
                connections: JSON.parse(JSON.stringify(GameState.connections))
            };
            GameState.redoStack.push(currentState);

            // Restore previous state
            const prevState = GameState.undoStack.pop();
            GameState.components = prevState.components;
            GameState.connections = prevState.connections;

            closeConfigPanel();
            renderComponents();
            renderConnections();
            updateStatus('Undo');
        }

        function redo() {
            if (GameState.redoStack.length === 0) {
                updateStatus('Nothing to redo');
                return;
            }
            // Save current state to undo stack
            const currentState = {
                components: JSON.parse(JSON.stringify(GameState.components)),
                connections: JSON.parse(JSON.stringify(GameState.connections))
            };
            GameState.undoStack.push(currentState);

            // Restore next state
            const nextState = GameState.redoStack.pop();
            GameState.components = nextState.components;
            GameState.connections = nextState.connections;

            closeConfigPanel();
            renderComponents();
            renderConnections();
            updateStatus('Redo');
        }

        // ============================================
        // COMPONENT DEFINITIONS
        // ============================================
        const ComponentTypes = {
            laser: {
                name: 'Laser',
                symbol: 'L',
                width: 1,
                height: 1,
                ports: {
                    out: { x: 1, y: 0.5, type: 'output' }
                },
                params: {
                    name: { label: 'Instrument ID', default: 'LASER-1', type: 'text' },
                    wavelength: { label: 'Wavelength (nm)', default: 1550, min: 1500, max: 1600, step: 0.1 },
                    power: { label: 'Power (dBm)', default: 0, min: -20, max: 10, step: 0.1 }
                },
                color: '#ff6b6b'
            },
            coupler: {
                name: 'Coupler',
                symbol: 'DC',
                width: 2,
                height: 2,
                ports: {
                    in1: { x: 0, y: 0.25, type: 'input' },
                    in2: { x: 0, y: 0.75, type: 'input' },
                    out1: { x: 1, y: 0.25, type: 'output' },
                    out2: { x: 1, y: 0.75, type: 'output' }
                },
                params: {
                    split: { label: 'Split ratio (0-1)', default: 0.5, min: 0, max: 1, step: 0.01 }
                },
                color: '#a29bfe'
            },
            phase_shifter: {
                name: 'Phase Shifter',
                symbol: 'φ',
                width: 1,
                height: 1,
                ports: {
                    in: { x: 0, y: 0.5, type: 'input' },
                    out: { x: 1, y: 0.5, type: 'output' },
                    ctrl: { x: 0.5, y: 1, type: 'electrical_input' }
                },
                params: {
                    ps_type: { label: 'Type', default: 'thermal', type: 'select', options: ['thermal', 'electro-optic'] },
                    v_pi: { label: 'Vπ (V)', default: 5, min: 0.5, max: 20, step: 0.5 }
                },
                color: '#fdcb6e'
            },
            dac: {
                name: 'DAC',
                symbol: 'DAC',
                width: 2,
                height: 2,
                ports: {
                    ch1: { x: 1, y: 0.25, type: 'electrical_output' },
                    ch2: { x: 1, y: 0.75, type: 'electrical_output' }
                },
                params: {
                    name: { label: 'Instrument ID', default: 'DAC-1', type: 'text' }
                },
                color: '#ff7675'
            },
            ring: {
                name: 'Ring Resonator',
                symbol: 'R',
                width: 2,
                height: 2,
                ports: {
                    in: { x: 0, y: 0.25, type: 'input' },
                    through: { x: 1, y: 0.25, type: 'output' },
                    add: { x: 1, y: 0.75, type: 'input', conditional: 'add_drop' },
                    drop: { x: 0, y: 0.75, type: 'output', conditional: 'add_drop' }
                },
                params: {
                    radius: { label: 'Radius (μm)', default: 10, min: 5, max: 50, step: 1 },
                    kappa: { label: 'Coupling κ', default: 0.1, min: 0.01, max: 0.5, step: 0.01 },
                    add_drop: { label: 'Add/Drop config', default: false, type: 'checkbox' },
                    sensing: { label: 'Sensing window', default: false, type: 'checkbox' }
                },
                color: '#e17055'
            },
            detector: {
                name: 'Detector',
                symbol: 'D',
                width: 1,
                height: 1,
                ports: {
                    in: { x: 0, y: 0.5, type: 'input' }
                },
                params: {
                    name: { label: 'Instrument ID', default: 'PM-1', type: 'text' },
                    responsivity: { label: 'Responsivity (A/W)', default: 1.0, min: 0.1, max: 2, step: 0.1 }
                },
                color: '#00b894'
            }
        };

        // ============================================
        // PUZZLE DEFINITIONS
        // ============================================
        const Puzzles = [
            {
                id: 'hello_photon',
                name: 'Hello Photon',
                arc: 'Arc 1: Basics',
                client: 'Lightpath Training Academy',
                description: 'Welcome to Lightpath, new recruit! Before we send you out to the field, you need to pass certification. Your first test: demonstrate that you can connect a basic optical link and verify signal integrity.\n\nConnect a laser to a detector and confirm the power level reaches the target.',
                objective: 'Measure 0 dBm ± 0.5 dB at the detector',
                availableComponents: ['laser', 'detector'],
                testCases: [
                    {
                        name: 'Basic measurement',
                        conditions: {},
                        expected: { 'PM-1': { value: 0, tolerance: 0.5, unit: 'dBm', comparison: 'equals' } }
                    }
                ],
                hints: [
                    'Click "Laser" in the palette, then click the grid to place it',
                    'Connect the laser\'s output port (orange) to the detector\'s input port (blue)',
                    'Use rm.open("PM-1").query(":POW?") to read the power'
                ],
                starterCode: `// Configure and measure
const laser = rm.open("LASER-1");
laser.write(":WAV 1550nm");
laser.write(":POW 0dBm");
laser.write(":OUTP ON");

const pm = rm.open("PM-1");
const power = parseFloat(pm.query(":POW?"));
console.log("Measured power: " + power + " dBm");

return { "PM-1": power };`
            },
            {
                id: 'split_decision',
                name: 'Split Decision',
                arc: 'Arc 1: Basics',
                client: 'Lightpath Training Academy',
                description: 'Good work on the first test! Now let\'s learn about beam splitting. Directional couplers can divide optical power between multiple paths—essential for tap monitors and signal distribution.\n\nDesign a 50/50 splitter that divides the signal equally between two output detectors.',
                objective: 'Split light 50/50: PM-1 and PM-2 should both read -3 dBm ± 0.5 dB',
                availableComponents: ['laser', 'coupler', 'detector'],
                testCases: [
                    {
                        name: '50/50 split',
                        conditions: {},
                        expected: {
                            'PM-1': { value: -3, tolerance: 0.5, unit: 'dBm', comparison: 'equals' },
                            'PM-2': { value: -3, tolerance: 0.5, unit: 'dBm', comparison: 'equals' }
                        }
                    }
                ],
                hints: [
                    'A 50/50 coupler has split ratio = 0.5',
                    'Connect laser → coupler input, coupler outputs → two detectors',
                    'Name detectors PM-1 and PM-2 in their config panels'
                ],
                starterCode: `// Configure and measure both outputs
const laser = rm.open("LASER-1");
laser.write(":WAV 1550nm");
laser.write(":POW 0dBm");
laser.write(":OUTP ON");

const pm1 = rm.open("PM-1");
const pm2 = rm.open("PM-2");

const p1 = parseFloat(pm1.query(":POW?"));
const p2 = parseFloat(pm2.query(":POW?"));

console.log("PM-1: " + p1 + " dBm");
console.log("PM-2: " + p2 + " dBm");

return { "PM-1": p1, "PM-2": p2 };`
            },
            {
                id: 'interference',
                name: 'Interference',
                arc: 'Arc 1: Basics',
                client: 'Lightpath Training Academy',
                description: 'Final certification exam! Time to demonstrate wave interference. A Mach-Zehnder Interferometer splits light into two paths and recombines them. By controlling the phase difference, you can route power to either output.\n\nBuild an MZI and tune it so that constructive interference routes all power to PM-1.',
                objective: 'Route all light to PM-1 (> -0.5 dBm), minimize PM-2 (< -15 dBm)',
                availableComponents: ['laser', 'coupler', 'phase_shifter', 'dac', 'detector'],
                testCases: [
                    {
                        name: 'Constructive at port 1',
                        conditions: {},
                        expected: {
                            'PM-1': { value: -0.5, unit: 'dBm', comparison: 'greater' },
                            'PM-2': { value: -15, unit: 'dBm', comparison: 'less' }
                        }
                    }
                ],
                hints: [
                    'MZI structure: coupler → two arms → coupler → outputs',
                    'Place a phase shifter in one arm, connect DAC to its control input',
                    'With Vπ=5V: 0V gives 0 phase, 5V gives π phase, 10V gives 2π phase'
                ],
                starterCode: `// Measure MZI outputs - tune DAC voltage for constructive interference
const laser = rm.open("LASER-1");
laser.write(":WAV 1550nm");
laser.write(":POW 0dBm");
laser.write(":OUTP ON");

// Set DAC voltage to control phase shifter
const dac = rm.open("DAC-1");
dac.write(":CH1 0V");  // Try different voltages!

const pm1 = rm.open("PM-1");
const pm2 = rm.open("PM-2");

const p1 = parseFloat(pm1.query(":POW?"));
const p2 = parseFloat(pm2.query(":POW?"));

console.log("PM-1: " + p1.toFixed(2) + " dBm");
console.log("PM-2: " + p2.toFixed(2) + " dBm");

return { "PM-1": p1, "PM-2": p2 };`
            },
            {
                id: 'the_switch',
                name: 'The Switch',
                arc: 'Arc 1: Basics',
                client: 'DataLink Corp',
                description: 'Congratulations on your certification! Your first real client needs a 2x1 optical switch for their data center. When a fiber fails, they need to instantly reroute traffic to the backup line.\n\nBuild an MZI-based switch that toggles between outputs based on DAC control voltage.',
                objective: 'At 0V: PM-1 high, PM-2 low. At Vπ: PM-1 low, PM-2 high',
                availableComponents: ['laser', 'coupler', 'phase_shifter', 'dac', 'detector'],
                testCases: [
                    {
                        name: 'Switch to Port 1 (0V)',
                        conditions: { control_voltage: 0 },
                        expected: {
                            'PM-1': { value: -1, unit: 'dBm', comparison: 'greater' },
                            'PM-2': { value: -10, unit: 'dBm', comparison: 'less' }
                        }
                    },
                    {
                        name: 'Switch to Port 2 (Vπ)',
                        conditions: { control_voltage: 5 },
                        expected: {
                            'PM-1': { value: -10, unit: 'dBm', comparison: 'less' },
                            'PM-2': { value: -1, unit: 'dBm', comparison: 'greater' }
                        }
                    }
                ],
                hints: [
                    'Place a DAC and connect its CH1 output to the phase shifter control input',
                    'Use condition.control_voltage to set the DAC output',
                    'With default Vπ=5V, setting DAC to 5V gives π phase shift'
                ],
                starterCode: `// Optical switch - control phase via DAC voltage
const laser = rm.open("LASER-1");
laser.write(":WAV 1550nm");
laser.write(":POW 0dBm");
laser.write(":OUTP ON");

// Get the control voltage from test condition
const voltage = condition.control_voltage || 0;

// Set the DAC voltage (connect DAC CH1 to phase shifter!)
const dac = rm.open("DAC-1");
dac.write(":CH1 " + voltage + "V");

const pm1 = rm.open("PM-1");
const pm2 = rm.open("PM-2");

const p1 = parseFloat(pm1.query(":POW?"));
const p2 = parseFloat(pm2.query(":POW?"));

console.log("DAC voltage: " + voltage.toFixed(2) + " V");
console.log("PM-1: " + p1.toFixed(2) + " dBm");
console.log("PM-2: " + p2.toFixed(2) + " dBm");

return { "PM-1": p1, "PM-2": p2 };`
            },
            {
                id: 'ring_around',
                name: 'Ring Around',
                arc: 'Arc 2: Sensing',
                client: 'Environmental Systems Inc.',
                description: 'Your client needs a gas sensor for methane detection at industrial sites. Ring resonators have sharp wavelength-dependent transmission—perfect for sensing applications. The target absorption line is at 1550 nm.\n\nDesign a ring resonator whose resonance wavelength matches the target. Adjust the ring radius to tune the resonance position.',
                objective: 'Design a ring with resonance at 1550 nm ± 0.5 nm',
                availableComponents: ['laser', 'ring', 'detector'],
                testCases: [
                    {
                        name: 'Resonance at target wavelength',
                        conditions: { target_wavelength: 1550 },
                        expected: {
                            'resonance': { value: 1550, tolerance: 0.5, unit: 'nm', comparison: 'equals' }
                        }
                    }
                ],
                hints: [
                    'Connect laser → ring input, ring through → detector',
                    'Sweep the laser wavelength and record power at each step',
                    'The resonance is where power dips (light couples into ring)',
                    'Adjust the ring radius in the component settings to shift the resonance wavelength'
                ],
                starterCode: `// Find ring resonance by wavelength sweep
const laser = rm.open("LASER-1");
laser.write(":POW 0dBm");
laser.write(":OUTP ON");

const pm = rm.open("PM-1");

let minPower = Infinity;
let resonanceWav = 1550;

// Arrays for plotting
const wavelengths = [];
const powers = [];

// Sweep wavelength
for (let wav = 1545; wav <= 1555; wav += 0.1) {
    laser.write(":WAV " + wav + "nm");
    const power = parseFloat(pm.query(":POW?"));

    wavelengths.push(wav);
    powers.push(power);

    if (power < minPower) {
        minPower = power;
        resonanceWav = wav;
    }
}

// Plot the resonance spectrum
plot(wavelengths, powers, {
    title: "Ring Resonator Transmission Spectrum",
    xlabel: "Wavelength (nm)",
    ylabel: "Power (dBm)"
});

console.log("Found resonance at: " + resonanceWav.toFixed(1) + " nm");
console.log("Dip depth: " + minPower.toFixed(2) + " dBm");

return { "resonance": resonanceWav };`
            },
            {
                id: 'gas_alarm',
                name: 'Gas Alarm',
                arc: 'Arc 2: Sensing',
                client: 'Environmental Systems Inc.',
                description: 'Your client is impressed with the ring design! Now they need the full sensing solution. The ring\'s sensing window is coated with a polymer that changes refractive index when methane is present.\n\nPosition your laser on the resonance slope so that even a small shift produces a large change in output power—an optical alarm signal.',
                objective: 'Air: LOW (< -10 dBm), Gas present: HIGH (> -3 dBm)',
                availableComponents: ['laser', 'ring', 'detector'],
                testCases: [
                    {
                        name: 'Air (baseline)',
                        conditions: { gas_present: false, delta_n: 0 },
                        expected: {
                            'PM-1': { value: -10, unit: 'dBm', comparison: 'less' }
                        }
                    },
                    {
                        name: 'Gas present',
                        conditions: { gas_present: true, delta_n: 0.002 },
                        expected: {
                            'PM-1': { value: -3, unit: 'dBm', comparison: 'greater' }
                        }
                    }
                ],
                hints: [
                    'Enable "Sensing window" on the ring resonator',
                    'Position laser wavelength on the slope of the resonance',
                    'When gas shifts the resonance, transmission changes dramatically'
                ],
                starterCode: `// Gas detection via ring resonance shift
const laser = rm.open("LASER-1");
laser.write(":POW 0dBm");
laser.write(":OUTP ON");

// Position laser on the slope of resonance
// You'll need to find the right wavelength!
laser.write(":WAV 1550.3nm");

const pm = rm.open("PM-1");
const power = parseFloat(pm.query(":POW?"));

console.log("Detection power: " + power.toFixed(2) + " dBm");
console.log("Gas present: " + (condition.gas_present ? "YES" : "NO"));

return { "PM-1": power };`
            }
        ];

        // ============================================
        // PHASE EXPRESSION PARSER
        // ============================================
        function parsePhaseExpression(expr) {
            // Parse expressions like: pi, 2pi, pi/2, 3/4 pi, 3pi/4, 0.5pi, etc.
            if (typeof expr === 'number') return expr;

            const str = String(expr).toLowerCase().replace(/\s+/g, '').replace(/π/g, 'pi');

            // Try to parse as pure number first
            const num = parseFloat(str);
            if (!isNaN(num) && !str.includes('pi')) {
                return num;
            }

            // Handle various pi formats
            const PI = Math.PI;

            // Patterns to match:
            // "pi" -> PI
            // "2pi" or "2*pi" -> 2*PI
            // "pi/2" -> PI/2
            // "pi/4" -> PI/4
            // "3pi/4" or "3*pi/4" -> 3*PI/4
            // "3/4pi" or "3/4*pi" -> 0.75*PI
            // "-pi" -> -PI
            // "0.5pi" -> 0.5*PI

            let result = 0;

            // Pattern: fraction before pi, like "3/4pi" or "3/4*pi"
            let match = str.match(/^(-?[\d.]+)\/([\d.]+)\*?pi$/);
            if (match) {
                result = (parseFloat(match[1]) / parseFloat(match[2])) * PI;
                return result;
            }

            // Pattern: coefficient * pi / divisor, like "3pi/4" or "3*pi/4"
            match = str.match(/^(-?[\d.]*)\*?pi\/([\d.]+)$/);
            if (match) {
                const coef = match[1] === '' || match[1] === '-' ? (match[1] === '-' ? -1 : 1) : parseFloat(match[1]);
                result = (coef * PI) / parseFloat(match[2]);
                return result;
            }

            // Pattern: just "pi/number"
            match = str.match(/^-?pi\/([\d.]+)$/);
            if (match) {
                const sign = str.startsWith('-') ? -1 : 1;
                result = sign * PI / parseFloat(match[1]);
                return result;
            }

            // Pattern: coefficient * pi, like "2pi" or "2*pi" or "0.5pi"
            match = str.match(/^(-?[\d.]*)\*?pi$/);
            if (match) {
                const coef = match[1] === '' || match[1] === '-' ? (match[1] === '-' ? -1 : 1) : parseFloat(match[1]);
                result = coef * PI;
                return result;
            }

            // Pattern: just "pi"
            if (str === 'pi') return PI;
            if (str === '-pi') return -PI;

            // Fallback: try to evaluate as number
            return parseFloat(expr) || 0;
        }

        function formatPhaseValue(radians) {
            // Convert radians back to a nice display format
            const PI = Math.PI;
            const tolerance = 0.001;

            if (Math.abs(radians) < tolerance) return '0';
            if (Math.abs(radians - PI) < tolerance) return 'π';
            if (Math.abs(radians + PI) < tolerance) return '-π';
            if (Math.abs(radians - 2*PI) < tolerance) return '2π';
            if (Math.abs(radians - PI/2) < tolerance) return 'π/2';
            if (Math.abs(radians - PI/4) < tolerance) return 'π/4';
            if (Math.abs(radians - 3*PI/4) < tolerance) return '3π/4';
            if (Math.abs(radians - 3*PI/2) < tolerance) return '3π/2';

            // Check for simple fractions of pi
            const ratio = radians / PI;
            if (Math.abs(ratio - Math.round(ratio)) < tolerance) {
                const n = Math.round(ratio);
                if (n === 1) return 'π';
                if (n === -1) return '-π';
                return n + 'π';
            }

            // Otherwise show decimal
            return radians.toFixed(3);
        }

        // ============================================
        // PHYSICS SIMULATION
        // ============================================
        class Complex {
            constructor(re = 0, im = 0) {
                this.re = re;
                this.im = im;
            }

            static fromPolar(mag, phase) {
                return new Complex(mag * Math.cos(phase), mag * Math.sin(phase));
            }

            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }

            mul(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }

            scale(s) {
                return new Complex(this.re * s, this.im * s);
            }

            magnitude() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }

            phase() {
                return Math.atan2(this.im, this.re);
            }

            power() {
                return this.re * this.re + this.im * this.im;
            }
        }

        class Simulation {
            constructor(components, connections, wavelength = 1550, conditions = {}) {
                this.components = components;
                this.connections = connections;
                this.wavelength = wavelength;
                this.conditions = conditions;
                this.fields = {};
                this.detectorOutputs = {};
            }

            run() {
                // Initialize fields at all ports
                this.initializeFields();

                // Get laser power
                const lasers = this.components.filter(c => c.type === 'laser');
                const laserFields = {};
                for (const laser of lasers) {
                    const powerDbm = laser.params.power || 0;
                    const powerWatts = Math.pow(10, powerDbm / 10) / 1000;
                    const amplitude = Math.sqrt(powerWatts);
                    laserFields[this.portKey(laser.id, 'out')] = new Complex(amplitude, 0);
                }

                // Propagate through circuit (iterate for convergence)
                for (let iter = 0; iter < 10; iter++) {
                    // Reset all fields except outputs that were just computed
                    const newFields = {};
                    for (const key of Object.keys(this.fields)) {
                        newFields[key] = new Complex(0, 0);
                    }

                    // Set laser outputs
                    for (const [key, field] of Object.entries(laserFields)) {
                        newFields[key] = field;
                    }

                    // Propagate through connections
                    for (const conn of this.connections) {
                        const sourceKey = this.portKey(conn.from.componentId, conn.from.port);
                        const sourceField = this.fields[sourceKey];
                        if (sourceField && sourceField.magnitude() > 0) {
                            const destKey = this.portKey(conn.to.componentId, conn.to.port);
                            newFields[destKey] = newFields[destKey].add(sourceField);
                        }
                    }

                    this.fields = newFields;

                    // Process each component
                    for (const comp of this.components) {
                        this.processComponent(comp);
                    }
                }

                // Collect detector outputs
                const detectors = this.components.filter(c => c.type === 'detector');
                for (const det of detectors) {
                    const field = this.fields[this.portKey(det.id, 'in')] || new Complex(0, 0);
                    const powerWatts = field.power();
                    const powerDbm = powerWatts > 0 ? 10 * Math.log10(powerWatts * 1000) : -100;
                    const name = det.params.name || 'PM-1';
                    this.detectorOutputs[name] = powerDbm;
                }

                return this.detectorOutputs;
            }

            initializeFields() {
                for (const comp of this.components) {
                    const def = ComponentTypes[comp.type];
                    if (def && def.ports) {
                        for (const portName of Object.keys(def.ports)) {
                            this.fields[this.portKey(comp.id, portName)] = new Complex(0, 0);
                        }
                    }
                }
            }

            processComponent(comp) {
                const type = comp.type;

                switch (type) {
                    case 'coupler': {
                        const in1 = this.fields[this.portKey(comp.id, 'in1')] || new Complex(0, 0);
                        const in2 = this.fields[this.portKey(comp.id, 'in2')] || new Complex(0, 0);
                        // Split ratio is power fraction to cross port, κ² = split
                        const split = comp.params.split !== undefined ? comp.params.split : 0.5;
                        const kappa = Math.sqrt(split);
                        const t = Math.sqrt(1 - split);

                        // Transfer matrix: [t, i*kappa; i*kappa, t]
                        const ik = new Complex(0, kappa);
                        const out1 = in1.scale(t).add(in2.mul(ik));
                        const out2 = in1.mul(ik).add(in2.scale(t));

                        this.fields[this.portKey(comp.id, 'out1')] = out1;
                        this.fields[this.portKey(comp.id, 'out2')] = out2;
                        break;
                    }

                    case 'phase_shifter': {
                        const input = this.fields[this.portKey(comp.id, 'in')];
                        if (input.magnitude() > 0) {
                            // Get voltage from electrical connection
                            const voltage = this.getControlVoltage(comp.id, 'ctrl');
                            const v_pi = comp.params.v_pi || 5;
                            const phi = (voltage / v_pi) * Math.PI;
                            const phasor = Complex.fromPolar(1, phi);
                            this.fields[this.portKey(comp.id, 'out')] = input.mul(phasor);
                        }
                        break;
                    }

                    case 'ring': {
                        const input = this.fields[this.portKey(comp.id, 'in')];
                        if (input.magnitude() > 0) {
                            const radius = comp.params.radius || 10;
                            const kappa = comp.params.kappa || 0.1;
                            const sensing = comp.params.sensing || false;

                            // Ring physics
                            const n_eff = 2.4 + (sensing && this.conditions.delta_n ? this.conditions.delta_n : 0);
                            const L = 2 * Math.PI * radius * 1e-6; // circumference in meters
                            const lambda = this.wavelength * 1e-9; // wavelength in meters
                            const phi = 2 * Math.PI * n_eff * L / lambda;

                            const t = Math.sqrt(1 - kappa * kappa);
                            const a = 0.99; // round-trip amplitude (slight loss)

                            // Through port transfer function
                            const expIPhi = Complex.fromPolar(a, phi);
                            const numerator = new Complex(t, 0).add(expIPhi.scale(-1));
                            const denominator = new Complex(1, 0).add(expIPhi.scale(-t));

                            // Complex division
                            const denom_conj = new Complex(denominator.re, -denominator.im);
                            const denom_mag2 = denominator.power();
                            const H = numerator.mul(denom_conj).scale(1 / denom_mag2);

                            this.fields[this.portKey(comp.id, 'through')] = input.mul(H);

                            // Drop port (simplified)
                            const dropPower = 1 - H.power();
                            this.fields[this.portKey(comp.id, 'drop')] = Complex.fromPolar(
                                input.magnitude() * Math.sqrt(Math.max(0, dropPower)), 0
                            );
                        }
                        break;
                    }
                }
            }

            portKey(componentId, portName) {
                return `${componentId}:${portName}`;
            }

            getControlVoltage(componentId, portName) {
                // Find electrical connection to this port
                const conn = this.connections.find(c =>
                    c.isElectrical &&
                    c.to.componentId === componentId &&
                    c.to.port === portName
                );

                if (!conn) return 0;

                // Find the source component (DAC)
                const sourceComp = this.components.find(c => c.id === conn.from.componentId);
                if (!sourceComp || sourceComp.type !== 'dac') return 0;

                // Get DAC instrument state
                const dacName = sourceComp.params.name || 'DAC-1';
                const dacState = instrumentState.dacs[dacName];
                if (!dacState) return 0;

                // Return voltage from the appropriate channel
                return dacState[conn.from.port] || 0;
            }
        }

        // ============================================
        // INSTRUMENT API
        // ============================================
        let currentSimulation = null;
        let instrumentState = {
            lasers: {},
            detectors: {},
            dacs: {}
        };

        const ResourceManager = {
            open(name) {
                if (name.startsWith('LASER')) {
                    return new LaserInstrument(name);
                } else if (name.startsWith('PM')) {
                    return new PowerMeterInstrument(name);
                } else if (name.startsWith('DAC')) {
                    return new DACInstrument(name);
                }
                throw new Error(`Unknown instrument: ${name}`);
            }
        };

        class LaserInstrument {
            constructor(name) {
                this.name = name;
                if (!instrumentState.lasers[name]) {
                    instrumentState.lasers[name] = {
                        wavelength: 1550,
                        power: 0,
                        output: false
                    };
                }
            }

            write(cmd) {
                const state = instrumentState.lasers[this.name];
                if (cmd.startsWith(':WAV ')) {
                    const match = cmd.match(/:WAV ([\d.]+)nm/);
                    if (match) {
                        state.wavelength = parseFloat(match[1]);
                    }
                } else if (cmd.startsWith(':POW ')) {
                    const match = cmd.match(/:POW ([-\d.]+)dBm/);
                    if (match) {
                        state.power = parseFloat(match[1]);
                    }
                } else if (cmd === ':OUTP ON') {
                    state.output = true;
                } else if (cmd === ':OUTP OFF') {
                    state.output = false;
                }
            }

            query(cmd) {
                const state = instrumentState.lasers[this.name];
                if (cmd === ':WAV?') {
                    return state.wavelength.toFixed(2) + 'nm';
                } else if (cmd === ':POW?') {
                    return state.power.toFixed(2) + 'dBm';
                } else if (cmd === ':OUTP?') {
                    return state.output ? 'ON' : 'OFF';
                }
                return '';
            }
        }

        class PowerMeterInstrument {
            constructor(name) {
                this.name = name;
            }

            write(cmd) {
                // Power meter write commands (e.g., set averaging)
            }

            query(cmd) {
                if (cmd === ':POW?') {
                    // Update all laser components with their instrument state
                    const lasers = GameState.components.filter(c => c.type === 'laser');
                    let simWavelength = 1550;

                    for (const laser of lasers) {
                        const laserName = laser.params.name || 'LASER-1';
                        const laserState = instrumentState.lasers[laserName] || { wavelength: 1550, power: 0, output: true };
                        laser.params.wavelength = laserState.wavelength;
                        laser.params.power = laserState.output ? laserState.power : -100;
                        simWavelength = laserState.wavelength; // Use last configured wavelength
                    }

                    const sim = new Simulation(
                        GameState.components,
                        GameState.connections,
                        simWavelength,
                        currentTestConditions
                    );
                    const results = sim.run();

                    const power = results[this.name];
                    if (power !== undefined) {
                        return power.toFixed(2) + 'dBm';
                    }
                    return '-100.00dBm';
                }
                return '';
            }
        }

        class DACInstrument {
            constructor(name) {
                this.name = name;
                if (!instrumentState.dacs[name]) {
                    instrumentState.dacs[name] = {
                        ch1: 0,
                        ch2: 0
                    };
                }
            }

            write(cmd) {
                const state = instrumentState.dacs[this.name];
                // Commands like :CH1 2.5V or :CH2 0V
                const match = cmd.match(/:CH([12])\s+([-\d.]+)V?/i);
                if (match) {
                    const channel = 'ch' + match[1];
                    state[channel] = parseFloat(match[2]);
                }
            }

            query(cmd) {
                const state = instrumentState.dacs[this.name];
                if (cmd === ':CH1?') {
                    return state.ch1.toFixed(2) + 'V';
                } else if (cmd === ':CH2?') {
                    return state.ch2.toFixed(2) + 'V';
                }
                return '';
            }
        }

        let currentTestConditions = {};

        // ============================================
        // UI FUNCTIONS
        // ============================================

        // Helper: Get the actual scale factor for canvas SVG (accounts for preserveAspectRatio)
        function getCanvasScale() {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            const viewBox = canvas.viewBox.baseVal;
            // With preserveAspectRatio="xMinYMin meet", scale is the minimum of width/height ratios
            const scaleX = rect.width / viewBox.width;
            const scaleY = rect.height / viewBox.height;
            return Math.min(scaleX, scaleY);
        }

        function initCanvas() {
            const canvas = document.getElementById('game-canvas');

            // Use fixed cellSize for consistent sizing - board scrolls when window is small
            GameState.cellSize = 50;
            GameState.canvasPadding = 0;

            const gridWidth = GameState.gridSize.cols * GameState.cellSize;
            const gridHeight = GameState.gridSize.rows * GameState.cellSize;

            // Set explicit dimensions on SVG to allow scrolling
            canvas.setAttribute('width', gridWidth);
            canvas.setAttribute('height', gridHeight);
            canvas.setAttribute('viewBox', `0 0 ${gridWidth} ${gridHeight}`);
            canvas.innerHTML = '';

            // Draw grid
            const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gridGroup.id = 'grid';

            for (let y = 0; y < GameState.gridSize.rows; y++) {
                for (let x = 0; x < GameState.gridSize.cols; x++) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x * GameState.cellSize);
                    rect.setAttribute('y', y * GameState.cellSize);
                    rect.setAttribute('width', GameState.cellSize);
                    rect.setAttribute('height', GameState.cellSize);
                    rect.setAttribute('class', 'grid-cell');
                    rect.dataset.x = x;
                    rect.dataset.y = y;
                    rect.addEventListener('click', handleGridClick);
                    gridGroup.appendChild(rect);
                }
            }
            canvas.appendChild(gridGroup);

            // Connections layer
            const connGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            connGroup.id = 'connections';
            canvas.appendChild(connGroup);

            // Components layer
            const compGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            compGroup.id = 'components';
            canvas.appendChild(compGroup);

            // Connection preview layer
            const previewGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            previewGroup.id = 'preview';
            canvas.appendChild(previewGroup);

            // Selection layer (on top)
            const selectionGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            selectionGroup.id = 'selection-layer';
            canvas.appendChild(selectionGroup);

            // Add canvas-level mousedown for box selection
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
        }

        function handleCanvasMouseDown(e) {
            // Ignore if clicking on a component or port
            if (e.target.closest('.component') || e.target.classList.contains('port')) {
                return;
            }

            // Ignore if a palette item is being dragged
            if (GameState.paletteDragging) return;

            // Start box selection on empty canvas
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            const svgScale = 1 / getCanvasScale();  // screen to SVG
            const padding = GameState.canvasPadding || 0;

            const startX = (e.clientX - rect.left) * svgScale - padding;
            const startY = (e.clientY - rect.top) * svgScale - padding;

            // Clear previous selection unless Shift is held
            if (!e.shiftKey) {
                GameState.selectedComponents.clear();
                GameState.selectedComponent = null;
            }

            GameState.boxSelect = {
                startX,
                startY,
                currentX: startX,
                currentY: startY
            };

            closeConfigPanel();
            e.preventDefault();
        }

        function renderComponents() {
            const compGroup = document.getElementById('components');
            compGroup.innerHTML = '';

            for (const comp of GameState.components) {
                const g = createComponentSVG(comp);
                compGroup.appendChild(g);
            }

            document.getElementById('component-count').textContent = GameState.components.length;
        }

        function createComponentSVG(comp) {
            const def = ComponentTypes[comp.type];
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            let className = 'component';
            if (GameState.selectedComponent === comp.id) {
                className += ' selected';
            } else if (GameState.selectedComponents.has(comp.id)) {
                className += ' multi-selected';
            }
            g.setAttribute('class', className);
            g.dataset.id = comp.id;

            const x = comp.x * GameState.cellSize;
            const y = comp.y * GameState.cellSize;
            const w = def.width * GameState.cellSize;
            const h = def.height * GameState.cellSize;

            // Component body
            if (comp.type === 'ring') {
                // Ring resonator - circle with bus
                const ringCx = x + w/2;
                const ringCy = y + h/2;
                // Bus lines at 0.25 and 0.75 of height, ring fits between them
                const topBusY = y + h * 0.25;
                const bottomBusY = y + h * 0.75;
                const busGap = 4;
                // Ring radius sized to fit between bus lines with gap
                const ringRadius = (h * 0.25) - busGap;

                // Ring circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', ringCx);
                circle.setAttribute('cy', ringCy);
                circle.setAttribute('r', ringRadius);
                circle.setAttribute('fill', 'transparent');
                circle.setAttribute('stroke', def.color);
                circle.setAttribute('stroke-width', '3');
                g.appendChild(circle);

                // Top bus waveguide (input/through)
                const bus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                bus.setAttribute('x1', x);
                bus.setAttribute('y1', topBusY);
                bus.setAttribute('x2', x + w);
                bus.setAttribute('y2', topBusY);
                bus.setAttribute('stroke', def.color);
                bus.setAttribute('stroke-width', '2');
                g.appendChild(bus);

                // Bottom bus waveguide (add/drop) - only if add_drop is enabled
                if (comp.params.add_drop) {
                    const dropBus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    dropBus.setAttribute('x1', x);
                    dropBus.setAttribute('y1', bottomBusY);
                    dropBus.setAttribute('x2', x + w);
                    dropBus.setAttribute('y2', bottomBusY);
                    dropBus.setAttribute('stroke', def.color);
                    dropBus.setAttribute('stroke-width', '2');
                    g.appendChild(dropBus);
                }
            } else {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x + 4);
                rect.setAttribute('y', y + 4);
                rect.setAttribute('width', w - 8);
                rect.setAttribute('height', h - 8);
                rect.setAttribute('rx', '4');
                rect.setAttribute('fill', def.color);
                rect.setAttribute('fill-opacity', '0.3');
                rect.setAttribute('stroke', def.color);
                rect.setAttribute('stroke-width', '2');
                g.appendChild(rect);
            }

            // Label
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x + w/2);
            text.setAttribute('y', y + h/2);
            text.setAttribute('class', 'component-label');
            text.textContent = def.symbol;
            g.appendChild(text);

            // Ports
            for (const [portName, portDef] of Object.entries(def.ports)) {
                // Skip conditional ports if condition not met
                if (portDef.conditional && !comp.params[portDef.conditional]) {
                    continue;
                }

                const px = x + portDef.x * w;
                const py = y + portDef.y * h;

                const isElectrical = portDef.type.startsWith('electrical');
                const isOutput = portDef.type === 'output' || portDef.type === 'electrical_output';

                const port = document.createElementNS('http://www.w3.org/2000/svg', isElectrical ? 'rect' : 'circle');
                if (isElectrical) {
                    // Square ports for electrical
                    port.setAttribute('x', px - 4);
                    port.setAttribute('y', py - 4);
                    port.setAttribute('width', '8');
                    port.setAttribute('height', '8');
                    port.setAttribute('class', 'port electrical' + (isOutput ? ' output' : ''));
                } else {
                    // Circle ports for optical
                    port.setAttribute('cx', px);
                    port.setAttribute('cy', py);
                    port.setAttribute('r', '5');
                    port.setAttribute('class', 'port' + (isOutput ? ' output' : ''));
                }
                port.dataset.componentId = comp.id;
                port.dataset.port = portName;
                port.dataset.portType = portDef.type;
                port.addEventListener('click', handlePortClick);
                port.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    GameState.connectionDragging = {
                        componentId: comp.id,
                        port: portName,
                        portDef: portDef,
                        startX: px,
                        startY: py
                    };
                    const isElec = portDef.type.startsWith('electrical');
                    updateStatus(`Drag to another port to create ${isElec ? 'wire' : 'waveguide'}`);
                });
                g.appendChild(port);
            }

            // Drag handler for component
            g.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('port')) return;
                e.preventDefault();

                const canvas = document.getElementById('game-canvas');
                const rect = canvas.getBoundingClientRect();
                const svgScale = 1 / getCanvasScale();  // screen to SVG
                const padding = GameState.canvasPadding || 0;
                const mouseX = (e.clientX - rect.left) * svgScale - padding;
                const mouseY = (e.clientY - rect.top) * svgScale - padding;

                // Close config panel during drag to prevent it from blocking
                closeConfigPanel();

                saveState();

                // Check if this component is part of multi-selection
                if (GameState.selectedComponents.has(comp.id) && GameState.selectedComponents.size > 1) {
                    // Start multi-drag - store original positions and click offset from this component
                    const offsets = new Map();
                    for (const compId of GameState.selectedComponents) {
                        const c = GameState.components.find(x => x.id === compId);
                        if (c) {
                            offsets.set(compId, { x: c.x, y: c.y });
                        }
                    }
                    // Calculate offset from mouse to the clicked component's corner
                    const clickOffsetX = mouseX - comp.x * GameState.cellSize;
                    const clickOffsetY = mouseY - comp.y * GameState.cellSize;
                    GameState.multiDrag = {
                        anchorComp: comp,
                        clickOffsetX,
                        clickOffsetY,
                        offsets,
                        hasMoved: false
                    };
                } else {
                    // Single component drag - clear multi-selection
                    if (!e.shiftKey) {
                        GameState.selectedComponents.clear();
                    }
                    GameState.dragging = {
                        componentId: comp.id,
                        startX: comp.x,
                        startY: comp.y,
                        offsetX: mouseX - comp.x * GameState.cellSize,
                        offsetY: mouseY - comp.y * GameState.cellSize,
                        hasMoved: false
                    };
                    GameState.selectedComponent = comp.id;
                }

                renderComponents();
            });

            return g;
        }

        function handleCanvasMouseMove(e) {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            const svgScale = 1 / getCanvasScale();  // screen to SVG
            const padding = GameState.canvasPadding || 0;
            const mouseX = (e.clientX - rect.left) * svgScale - padding;
            const mouseY = (e.clientY - rect.top) * svgScale - padding;

            // Handle connection drag preview
            if (GameState.connectionDragging) {
                const preview = document.getElementById('preview');
                const { startX, startY, portDef } = GameState.connectionDragging;
                const isElectrical = portDef.type.startsWith('electrical');
                preview.innerHTML = `<line class="connection-preview"
                    x1="${startX}" y1="${startY}"
                    x2="${mouseX}" y2="${mouseY}"
                    style="stroke: ${isElectrical ? 'var(--amber)' : 'var(--cyan)'}; ${isElectrical ? 'stroke-dasharray: 4, 4;' : ''}"/>`;
                return;
            }

            // Handle box selection
            if (GameState.boxSelect) {
                GameState.boxSelect.currentX = mouseX;
                GameState.boxSelect.currentY = mouseY;
                renderSelectionRect();
                return;
            }

            // Handle multi-drag (allow movement outside canvas with ghost)
            if (GameState.multiDrag) {
                GameState.multiDrag.hasMoved = true;

                // Check if mouse is inside canvas
                const insideCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                                    e.clientY >= rect.top && e.clientY <= rect.bottom;

                if (insideCanvas) {
                    // Hide ghost, update component positions
                    hideComponentGhost();

                    // Calculate where the anchor component should be (using offset like single drag)
                    const anchorOriginal = GameState.multiDrag.offsets.get(GameState.multiDrag.anchorComp.id);
                    const anchorNewX = Math.round((mouseX - GameState.multiDrag.clickOffsetX) / GameState.cellSize);
                    const anchorNewY = Math.round((mouseY - GameState.multiDrag.clickOffsetY) / GameState.cellSize);
                    const dx = anchorNewX - anchorOriginal.x;
                    const dy = anchorNewY - anchorOriginal.y;

                    // Check if all components can move
                    let canMove = true;
                    for (const compId of GameState.selectedComponents) {
                        const comp = GameState.components.find(c => c.id === compId);
                        if (!comp) continue;
                        const def = ComponentTypes[comp.type];
                        const offset = GameState.multiDrag.offsets.get(compId);
                        const newX = offset.x + dx;
                        const newY = offset.y + dy;

                        // Check bounds
                        if (newX < 0 || newY < 0 ||
                            newX + def.width > GameState.gridSize.cols ||
                            newY + def.height > GameState.gridSize.rows) {
                            canMove = false;
                            break;
                        }

                        // Check collision with non-selected components
                        for (const other of GameState.components) {
                            if (GameState.selectedComponents.has(other.id)) continue;
                            const otherDef = ComponentTypes[other.type];
                            if (!(newX + def.width <= other.x || newX >= other.x + otherDef.width ||
                                  newY + def.height <= other.y || newY >= other.y + otherDef.height)) {
                                canMove = false;
                                break;
                            }
                        }
                        if (!canMove) break;
                    }

                    if (canMove && (dx !== 0 || dy !== 0)) {
                        for (const compId of GameState.selectedComponents) {
                            const comp = GameState.components.find(c => c.id === compId);
                            if (!comp) continue;
                            const offset = GameState.multiDrag.offsets.get(compId);
                            comp.x = offset.x + dx;
                            comp.y = offset.y + dy;
                        }
                        renderComponents();
                        renderConnections();
                    }
                } else {
                    // Outside canvas - show ghost, restore original positions
                    for (const compId of GameState.selectedComponents) {
                        const comp = GameState.components.find(c => c.id === compId);
                        if (!comp) continue;
                        const offset = GameState.multiDrag.offsets.get(compId);
                        comp.x = offset.x;
                        comp.y = offset.y;
                    }
                    renderComponents();
                    renderConnections();
                    showComponentGhost(e, GameState.selectedComponents.size + ' components');
                }
                return;
            }

            // Handle single component drag (allow movement outside canvas with ghost)
            if (!GameState.dragging) return;

            const comp = GameState.components.find(c => c.id === GameState.dragging.componentId);
            if (!comp) return;

            const def = ComponentTypes[comp.type];
            GameState.dragging.hasMoved = true;

            // Check if mouse is inside canvas
            const insideCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                                e.clientY >= rect.top && e.clientY <= rect.bottom;

            if (insideCanvas) {
                // Hide ghost, update component position
                hideComponentGhost();

                const newX = Math.round((mouseX - GameState.dragging.offsetX) / GameState.cellSize);
                const newY = Math.round((mouseY - GameState.dragging.offsetY) / GameState.cellSize);

                // Check bounds
                const clampedX = Math.max(0, Math.min(newX, GameState.gridSize.cols - def.width));
                const clampedY = Math.max(0, Math.min(newY, GameState.gridSize.rows - def.height));

                // Check overlap with other components
                let canPlace = true;
                for (const other of GameState.components) {
                    if (other.id === comp.id) continue;
                    const otherDef = ComponentTypes[other.type];
                    if (!(clampedX + def.width <= other.x || clampedX >= other.x + otherDef.width ||
                          clampedY + def.height <= other.y || clampedY >= other.y + otherDef.height)) {
                        canPlace = false;
                        break;
                    }
                }

                // Check overlap with waveguides (excluding connections from this component)
                if (canPlace && checkWaveguideCollision(clampedX, clampedY, def.width, def.height, comp.id)) {
                    canPlace = false;
                }

                if (canPlace && (comp.x !== clampedX || comp.y !== clampedY)) {
                    comp.x = clampedX;
                    comp.y = clampedY;
                    renderComponents();
                    renderConnections();
                }
            } else {
                // Outside canvas - show ghost, restore original position
                comp.x = GameState.dragging.startX;
                comp.y = GameState.dragging.startY;
                renderComponents();
                renderConnections();
                showComponentGhostForType(e, comp.type);
            }
        }

        function showComponentGhost(e, label) {
            const ghost = document.getElementById('drag-ghost') || createDragGhost();
            ghost.innerHTML = '';
            ghost.style.display = 'flex';
            ghost.style.alignItems = 'center';
            ghost.style.justifyContent = 'center';
            ghost.style.width = '80px';
            ghost.style.height = '40px';
            ghost.style.left = (e.clientX + 10) + 'px';
            ghost.style.top = (e.clientY - 20) + 'px';
            ghost.style.backgroundColor = 'var(--accent-blue)';
            ghost.style.borderRadius = '4px';
            ghost.style.color = 'white';
            ghost.style.fontSize = '11px';
            ghost.textContent = label;
        }

        function showComponentGhostForType(e, type) {
            const def = ComponentTypes[type];
            const scale = getCanvasScale();  // SVG to screen
            const ghostWidth = def.width * GameState.cellSize * scale;
            const ghostHeight = def.height * GameState.cellSize * scale;

            const ghost = document.getElementById('drag-ghost') || createDragGhost();
            ghost.style.display = 'block';
            ghost.style.width = ghostWidth + 'px';
            ghost.style.height = ghostHeight + 'px';
            ghost.style.left = (e.clientX + 10) + 'px';
            ghost.style.top = (e.clientY - ghostHeight / 2) + 'px';
            ghost.innerHTML = '';
            const svg = createComponentSvg(type, ghostWidth, ghostHeight);
            ghost.appendChild(svg);
        }

        function hideComponentGhost() {
            const ghost = document.getElementById('drag-ghost');
            if (ghost) ghost.style.display = 'none';
        }

        function renderSelectionRect() {
            const selectionLayer = document.getElementById('selection-layer');
            if (!selectionLayer) return;

            selectionLayer.innerHTML = '';

            if (!GameState.boxSelect) return;

            const { startX, startY, currentX, currentY } = GameState.boxSelect;
            const x = Math.min(startX, currentX);
            const y = Math.min(startY, currentY);
            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);

            if (width > 2 || height > 2) {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', width);
                rect.setAttribute('height', height);
                rect.setAttribute('class', 'selection-rect');
                selectionLayer.appendChild(rect);
            }
        }

        function handleCanvasMouseUp(e) {
            hideComponentGhost();

            // Handle connection drag completion
            if (GameState.connectionDragging) {
                const preview = document.getElementById('preview');
                preview.innerHTML = '';

                // Check if we released over a port
                const targetPort = e.target.closest('.port');
                if (targetPort && targetPort.dataset.componentId !== GameState.connectionDragging.componentId) {
                    const targetComponentId = targetPort.dataset.componentId;
                    const targetPortName = targetPort.dataset.port;
                    const targetComp = GameState.components.find(c => c.id === targetComponentId);
                    const targetDef = ComponentTypes[targetComp.type];
                    const targetPortDef = targetDef.ports[targetPortName];

                    const fromPortDef = GameState.connectionDragging.portDef;
                    const fromIsElectrical = fromPortDef.type.startsWith('electrical');
                    const toIsElectrical = targetPortDef.type.startsWith('electrical');

                    if (fromIsElectrical !== toIsElectrical) {
                        updateStatus('Cannot connect electrical to optical ports');
                    } else if ((fromPortDef.type === 'output' || fromPortDef.type === 'electrical_output') &&
                               (targetPortDef.type === 'input' || targetPortDef.type === 'electrical_input')) {
                        createConnection(
                            { componentId: GameState.connectionDragging.componentId, port: GameState.connectionDragging.port },
                            { componentId: targetComponentId, port: targetPortName },
                            fromIsElectrical
                        );
                    } else if ((fromPortDef.type === 'input' || fromPortDef.type === 'electrical_input') &&
                               (targetPortDef.type === 'output' || targetPortDef.type === 'electrical_output')) {
                        createConnection(
                            { componentId: targetComponentId, port: targetPortName },
                            { componentId: GameState.connectionDragging.componentId, port: GameState.connectionDragging.port },
                            fromIsElectrical
                        );
                    } else {
                        updateStatus('Connect output ports to input ports');
                    }
                }

                GameState.connectionDragging = null;
                return;
            }

            // Handle box selection completion
            if (GameState.boxSelect) {
                const { startX, startY, currentX, currentY } = GameState.boxSelect;
                const boxLeft = Math.min(startX, currentX) / GameState.cellSize;
                const boxTop = Math.min(startY, currentY) / GameState.cellSize;
                const boxRight = Math.max(startX, currentX) / GameState.cellSize;
                const boxBottom = Math.max(startY, currentY) / GameState.cellSize;

                // Select components that overlap with the selection box
                for (const comp of GameState.components) {
                    const def = ComponentTypes[comp.type];
                    const compRight = comp.x + def.width;
                    const compBottom = comp.y + def.height;

                    // Check if component overlaps with selection box
                    if (!(comp.x >= boxRight || compRight <= boxLeft ||
                          comp.y >= boxBottom || compBottom <= boxTop)) {
                        GameState.selectedComponents.add(comp.id);
                    }
                }

                GameState.boxSelect = null;
                renderSelectionRect();
                renderComponents();

                if (GameState.selectedComponents.size > 0) {
                    updateStatus(`Selected ${GameState.selectedComponents.size} component(s)`);
                }
                return;
            }

            // Handle multi-drag completion
            if (GameState.multiDrag) {
                const hasMoved = GameState.multiDrag.hasMoved;
                const offsets = GameState.multiDrag.offsets;

                // Check if dropped on palette (delete all selected)
                const palette = document.querySelector('.component-palette');
                const paletteRect = palette.getBoundingClientRect();
                if (e.clientX >= paletteRect.left && e.clientX <= paletteRect.right &&
                    e.clientY >= paletteRect.top && e.clientY <= paletteRect.bottom) {
                    // Delete all selected components
                    for (const compId of GameState.selectedComponents) {
                        GameState.connections = GameState.connections.filter(c =>
                            c.from.componentId !== compId && c.to.componentId !== compId
                        );
                        GameState.components = GameState.components.filter(c => c.id !== compId);
                    }
                    GameState.selectedComponents.clear();
                    GameState.multiDrag = null;
                    renderComponents();
                    renderConnections();
                    updateStatus('Components deleted');
                    return;
                }

                // If dropped outside canvas, restore original positions
                const canvas = document.getElementById('game-canvas');
                const rect = canvas.getBoundingClientRect();
                if (!(e.clientX >= rect.left && e.clientX <= rect.right &&
                      e.clientY >= rect.top && e.clientY <= rect.bottom)) {
                    for (const compId of GameState.selectedComponents) {
                        const comp = GameState.components.find(c => c.id === compId);
                        if (comp && offsets.has(compId)) {
                            const offset = offsets.get(compId);
                            comp.x = offset.x;
                            comp.y = offset.y;
                        }
                    }
                    renderComponents();
                    renderConnections();
                }

                GameState.multiDrag = null;
                return;
            }

            // Handle single component drag
            if (GameState.dragging) {
                const comp = GameState.components.find(c => c.id === GameState.dragging.componentId);
                const hasMoved = GameState.dragging.hasMoved;
                const componentId = GameState.dragging.componentId;
                const startX = GameState.dragging.startX;
                const startY = GameState.dragging.startY;
                GameState.dragging = null;

                if (comp) {
                    // Check if dropped on palette (delete)
                    const palette = document.querySelector('.component-palette');
                    const paletteRect = palette.getBoundingClientRect();
                    if (e.clientX >= paletteRect.left && e.clientX <= paletteRect.right &&
                        e.clientY >= paletteRect.top && e.clientY <= paletteRect.bottom) {
                        // Delete the component
                        GameState.connections = GameState.connections.filter(c =>
                            c.from.componentId !== componentId &&
                            c.to.componentId !== componentId
                        );
                        GameState.components = GameState.components.filter(c => c.id !== componentId);
                        GameState.selectedComponents.delete(componentId);
                        renderComponents();
                        renderConnections();
                        updateStatus('Component deleted');
                        return;
                    }

                    // If dropped outside canvas, restore original position
                    const canvas = document.getElementById('game-canvas');
                    const rect = canvas.getBoundingClientRect();
                    if (!(e.clientX >= rect.left && e.clientX <= rect.right &&
                          e.clientY >= rect.top && e.clientY <= rect.bottom)) {
                        comp.x = startX;
                        comp.y = startY;
                        renderComponents();
                        renderConnections();
                        return;
                    }

                    if (hasMoved) {
                        // Try to auto-connect ports after drag
                        autoConnectOverlappingPorts(comp);
                        renderConnections();
                    } else {
                        // Just a click - show config panel
                        showConfigPanel(comp.id);
                    }
                }
            }
        }

        function renderConnections() {
            const connGroup = document.getElementById('connections');
            connGroup.innerHTML = '';

            // Clear cached segments
            GameState.waveguideSegments = [];

            for (const conn of GameState.connections) {
                const fromComp = GameState.components.find(c => c.id === conn.from.componentId);
                const toComp = GameState.components.find(c => c.id === conn.to.componentId);

                if (!fromComp || !toComp) continue;

                const fromDef = ComponentTypes[fromComp.type];
                const toDef = ComponentTypes[toComp.type];

                const fromPort = fromDef.ports[conn.from.port];
                const toPort = toDef.ports[conn.to.port];

                if (!fromPort || !toPort) continue;

                const x1 = (fromComp.x + fromPort.x * fromDef.width) * GameState.cellSize;
                const y1 = (fromComp.y + fromPort.y * fromDef.height) * GameState.cellSize;
                const x2 = (toComp.x + toPort.x * toDef.width) * GameState.cellSize;
                const y2 = (toComp.y + toPort.y * toDef.height) * GameState.cellSize;

                // Create rectilinear path
                const path = createRectilinearPath(x1, y1, x2, y2, fromPort, toPort);

                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', path.map(p => `${p.x},${p.y}`).join(' '));
                polyline.setAttribute('class', 'connection' + (conn.isElectrical ? ' electrical' : ''));
                polyline.dataset.id = conn.id;
                polyline.addEventListener('click', () => deleteConnection(conn.id));
                connGroup.appendChild(polyline);

                // Cache segments for collision detection
                for (let i = 0; i < path.length - 1; i++) {
                    GameState.waveguideSegments.push({
                        x1: path[i].x / GameState.cellSize,
                        y1: path[i].y / GameState.cellSize,
                        x2: path[i + 1].x / GameState.cellSize,
                        y2: path[i + 1].y / GameState.cellSize,
                        connId: conn.id
                    });
                }
            }

            document.getElementById('connection-count').textContent = GameState.connections.length;
        }

        function checkWaveguideCollision(x, y, width, height, excludeCompId = null) {
            // Check if a component rectangle collides with any waveguide segment
            // Uses grid units (not pixels)
            const margin = 0.1; // Small margin to avoid edge cases

            for (const seg of GameState.waveguideSegments) {
                // Skip segments connected to excluded component
                if (excludeCompId) {
                    const conn = GameState.connections.find(c => c.id === seg.connId);
                    if (conn && (conn.from.componentId === excludeCompId || conn.to.componentId === excludeCompId)) {
                        continue;
                    }
                }
                // Check if line segment intersects rectangle
                // Convert segment to grid units (they're already in grid units)
                const sx1 = seg.x1, sy1 = seg.y1;
                const sx2 = seg.x2, sy2 = seg.y2;

                // Check if segment intersects with component rectangle
                // Component occupies area from (x, y) to (x+width, y+height)
                const rectLeft = x + margin;
                const rectRight = x + width - margin;
                const rectTop = y + margin;
                const rectBottom = y + height - margin;

                // Determine if the line segment crosses the rectangle
                // For horizontal segments (sy1 == sy2)
                if (Math.abs(sy1 - sy2) < 0.01) {
                    const segY = sy1;
                    if (segY > rectTop && segY < rectBottom) {
                        const segLeft = Math.min(sx1, sx2);
                        const segRight = Math.max(sx1, sx2);
                        if (segRight > rectLeft && segLeft < rectRight) {
                            return true;
                        }
                    }
                }
                // For vertical segments (sx1 == sx2)
                else if (Math.abs(sx1 - sx2) < 0.01) {
                    const segX = sx1;
                    if (segX > rectLeft && segX < rectRight) {
                        const segTop = Math.min(sy1, sy2);
                        const segBottom = Math.max(sy1, sy2);
                        if (segBottom > rectTop && segTop < rectBottom) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function createRectilinearPath(x1, y1, x2, y2, fromPort, toPort) {
            const points = [{ x: x1, y: y1 }];

            // Determine exit/entry directions based on port positions
            // Ports at edges exit perpendicular to that edge
            const getDirection = (port) => {
                if (port.x >= 0.9) return 'right';
                if (port.x <= 0.1) return 'left';
                if (port.y >= 0.9) return 'down';
                if (port.y <= 0.1) return 'up';
                // Default based on x position
                return port.x > 0.5 ? 'right' : 'left';
            };

            const fromDir = getDirection(fromPort);
            const toDir = getDirection(toPort);

            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const margin = GameState.cellSize * 0.5;

            // Simple case: direct horizontal or vertical line
            if (Math.abs(x1 - x2) < 1 && (fromDir === 'down' || fromDir === 'up') && (toDir === 'down' || toDir === 'up')) {
                // Vertical alignment, vertical ports - straight line
                points.push({ x: x2, y: y2 });
                return points;
            }
            if (Math.abs(y1 - y2) < 1 && (fromDir === 'left' || fromDir === 'right') && (toDir === 'left' || toDir === 'right')) {
                // Horizontal alignment, horizontal ports - straight line
                points.push({ x: x2, y: y2 });
                return points;
            }

            // Route based on from direction
            if (fromDir === 'right') {
                if (toDir === 'left') {
                    // Right to left - Z shape horizontal
                    points.push({ x: midX, y: y1 });
                    points.push({ x: midX, y: y2 });
                } else if (toDir === 'up' || toDir === 'down') {
                    // Right to vertical - L shape
                    points.push({ x: x2, y: y1 });
                } else {
                    // Right to right - U shape
                    const offsetX = Math.max(x1, x2) + margin;
                    points.push({ x: offsetX, y: y1 });
                    points.push({ x: offsetX, y: y2 });
                }
            } else if (fromDir === 'left') {
                if (toDir === 'right') {
                    // Left to right - Z shape horizontal
                    points.push({ x: midX, y: y1 });
                    points.push({ x: midX, y: y2 });
                } else if (toDir === 'up' || toDir === 'down') {
                    // Left to vertical - L shape
                    points.push({ x: x2, y: y1 });
                } else {
                    // Left to left - U shape
                    const offsetX = Math.min(x1, x2) - margin;
                    points.push({ x: offsetX, y: y1 });
                    points.push({ x: offsetX, y: y2 });
                }
            } else if (fromDir === 'down') {
                if (toDir === 'up') {
                    // Down to up - Z shape vertical
                    points.push({ x: x1, y: midY });
                    points.push({ x: x2, y: midY });
                } else if (toDir === 'left' || toDir === 'right') {
                    // Down to horizontal - L shape
                    points.push({ x: x1, y: y2 });
                } else {
                    // Down to down - U shape
                    const offsetY = Math.max(y1, y2) + margin;
                    points.push({ x: x1, y: offsetY });
                    points.push({ x: x2, y: offsetY });
                }
            } else if (fromDir === 'up') {
                if (toDir === 'down') {
                    // Up to down - Z shape vertical
                    points.push({ x: x1, y: midY });
                    points.push({ x: x2, y: midY });
                } else if (toDir === 'left' || toDir === 'right') {
                    // Up to horizontal - L shape
                    points.push({ x: x1, y: y2 });
                } else {
                    // Up to up - U shape
                    const offsetY = Math.min(y1, y2) - margin;
                    points.push({ x: x1, y: offsetY });
                    points.push({ x: x2, y: offsetY });
                }
            }

            points.push({ x: x2, y: y2 });
            return points;
        }

        function handleGridClick(e) {
            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            if (GameState.selectedPaletteItem) {
                placeComponent(GameState.selectedPaletteItem, x, y);
            }
        }

        function handlePortClick(e) {
            e.stopPropagation();
            const componentId = e.target.dataset.componentId;
            const portName = e.target.dataset.port;

            const comp = GameState.components.find(c => c.id === componentId);
            const def = ComponentTypes[comp.type];
            const portDef = def.ports[portName];

            if (GameState.connectingFrom) {
                // Complete connection
                if (GameState.connectingFrom.componentId !== componentId) {
                    // Check port compatibility (output to input, same signal type)
                    const fromComp = GameState.components.find(c => c.id === GameState.connectingFrom.componentId);
                    const fromDef = ComponentTypes[fromComp.type];
                    const fromPortDef = fromDef.ports[GameState.connectingFrom.port];

                    // Check signal type compatibility
                    const fromIsElectrical = fromPortDef.type.startsWith('electrical');
                    const toIsElectrical = portDef.type.startsWith('electrical');

                    if (fromIsElectrical !== toIsElectrical) {
                        updateStatus('Cannot connect electrical to optical ports');
                    } else if ((fromPortDef.type === 'output' || fromPortDef.type === 'electrical_output') &&
                               (portDef.type === 'input' || portDef.type === 'electrical_input')) {
                        createConnection(GameState.connectingFrom, { componentId, port: portName }, fromIsElectrical);
                    } else if ((fromPortDef.type === 'input' || fromPortDef.type === 'electrical_input') &&
                               (portDef.type === 'output' || portDef.type === 'electrical_output')) {
                        createConnection({ componentId, port: portName }, GameState.connectingFrom, fromIsElectrical);
                    }
                }
                GameState.connectingFrom = null;
                document.getElementById('preview').innerHTML = '';
            } else {
                // Start connection
                GameState.connectingFrom = { componentId, port: portName };
                const isElectrical = portDef.type.startsWith('electrical');
                updateStatus(`Click another port to create ${isElectrical ? 'wire' : 'waveguide'}`);
            }
        }

        function createConnection(from, to, isElectrical = false) {
            // Check if connection already exists
            const exists = GameState.connections.some(c =>
                c.from.componentId === from.componentId &&
                c.from.port === from.port &&
                c.to.componentId === to.componentId &&
                c.to.port === to.port
            );

            if (exists) {
                updateStatus(isElectrical ? 'Wire already exists' : 'Waveguide already exists');
                return;
            }

            // Check if output port already has a connection (can't split without splitter)
            const outputUsed = GameState.connections.some(c =>
                c.from.componentId === from.componentId &&
                c.from.port === from.port
            );

            if (outputUsed) {
                updateStatus('Output port already connected' + (isElectrical ? '' : ' - use a coupler to split'));
                return;
            }

            // Check if input port already has a connection
            const inputUsed = GameState.connections.some(c =>
                c.to.componentId === to.componentId &&
                c.to.port === to.port
            );

            if (inputUsed) {
                updateStatus('Input port already connected');
                return;
            }

            saveState();
            GameState.connections.push({
                id: 'conn_' + Date.now(),
                from,
                to,
                isElectrical
            });
            renderConnections();
            updateStatus(isElectrical ? 'Wire created' : 'Waveguide created');
        }

        function deleteConnection(id) {
            saveState();
            GameState.connections = GameState.connections.filter(c => c.id !== id);
            renderConnections();
            updateStatus('Waveguide deleted');
        }

        function autoConnectOverlappingPorts(newComp) {
            const newDef = ComponentTypes[newComp.type];
            const tolerance = 0.1; // Grid units tolerance for port overlap

            // Get all port positions for the new component
            for (const [newPortName, newPortDef] of Object.entries(newDef.ports)) {
                const newPortX = newComp.x + newPortDef.x * newDef.width;
                const newPortY = newComp.y + newPortDef.y * newDef.height;

                // Check against all other components
                for (const otherComp of GameState.components) {
                    if (otherComp.id === newComp.id) continue;

                    const otherDef = ComponentTypes[otherComp.type];

                    for (const [otherPortName, otherPortDef] of Object.entries(otherDef.ports)) {
                        const otherPortX = otherComp.x + otherPortDef.x * otherDef.width;
                        const otherPortY = otherComp.y + otherPortDef.y * otherDef.height;

                        // Check if ports overlap
                        if (Math.abs(newPortX - otherPortX) < tolerance &&
                            Math.abs(newPortY - otherPortY) < tolerance) {

                            // Check signal type compatibility
                            const newIsElectrical = newPortDef.type.startsWith('electrical');
                            const otherIsElectrical = otherPortDef.type.startsWith('electrical');
                            if (newIsElectrical !== otherIsElectrical) continue;

                            const newIsOutput = newPortDef.type === 'output' || newPortDef.type === 'electrical_output';
                            const otherIsOutput = otherPortDef.type === 'output' || otherPortDef.type === 'electrical_output';

                            // Determine connection direction (output -> input)
                            let from, to;
                            if (newIsOutput && !otherIsOutput) {
                                from = { componentId: newComp.id, port: newPortName };
                                to = { componentId: otherComp.id, port: otherPortName };
                            } else if (!newIsOutput && otherIsOutput) {
                                from = { componentId: otherComp.id, port: otherPortName };
                                to = { componentId: newComp.id, port: newPortName };
                            } else {
                                continue; // Same type ports don't connect
                            }

                            // Check if connection already exists
                            const exists = GameState.connections.some(c =>
                                c.from.componentId === from.componentId &&
                                c.from.port === from.port &&
                                c.to.componentId === to.componentId &&
                                c.to.port === to.port
                            );

                            // Check if output port already used
                            const outputUsed = GameState.connections.some(c =>
                                c.from.componentId === from.componentId &&
                                c.from.port === from.port
                            );

                            // Check if input port already used
                            const inputUsed = GameState.connections.some(c =>
                                c.to.componentId === to.componentId &&
                                c.to.port === to.port
                            );

                            if (!exists && !outputUsed && !inputUsed) {
                                GameState.connections.push({
                                    id: 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                                    from,
                                    to,
                                    isElectrical: newIsElectrical
                                });
                            }
                        }
                    }
                }
            }
        }

        function placeComponent(type, x, y) {
            const def = ComponentTypes[type];

            // Check bounds (must be within design area)
            if (x < 0 || y < 0 || x + def.width > GameState.gridSize.cols || y + def.height > GameState.gridSize.rows) {
                updateStatus('Component does not fit here');
                return;
            }

            // Check overlap with other components
            for (const comp of GameState.components) {
                const compDef = ComponentTypes[comp.type];
                if (!(x + def.width <= comp.x || x >= comp.x + compDef.width ||
                      y + def.height <= comp.y || y >= comp.y + compDef.height)) {
                    updateStatus('Space is occupied by component');
                    return;
                }
            }

            // Check overlap with waveguides
            if (checkWaveguideCollision(x, y, def.width, def.height)) {
                updateStatus('Space is occupied by waveguide');
                return;
            }

            const component = {
                id: 'comp_' + Date.now(),
                type,
                x,
                y,
                params: {}
            };

            // Set default params
            for (const [key, paramDef] of Object.entries(def.params)) {
                component.params[key] = paramDef.default;
            }

            // Auto-increment instrument IDs for lasers and detectors
            if (type === 'laser') {
                const existingLasers = GameState.components.filter(c => c.type === 'laser');
                const nextNum = existingLasers.length + 1;
                component.params.name = 'LASER-' + nextNum;
            } else if (type === 'detector') {
                const existingDetectors = GameState.components.filter(c => c.type === 'detector');
                const nextNum = existingDetectors.length + 1;
                component.params.name = 'PM-' + nextNum;
            }

            saveState();
            GameState.components.push(component);

            // Auto-connect overlapping ports
            autoConnectOverlappingPorts(component);

            renderComponents();
            renderConnections();
            updateStatus(`Placed ${def.name}`);
        }

        function selectComponent(id) {
            GameState.selectedComponent = id;
            renderComponents();
            showConfigPanel(id);
        }

        function showConfigPanel(id) {
            const comp = GameState.components.find(c => c.id === id);
            if (!comp) return;

            const def = ComponentTypes[comp.type];
            const panel = document.getElementById('config-panel');
            const fields = document.getElementById('config-fields');

            document.getElementById('config-component-name').textContent = def.name;
            fields.innerHTML = '';

            for (const [key, paramDef] of Object.entries(def.params)) {
                const field = document.createElement('div');
                field.className = 'config-field';

                const label = document.createElement('label');
                label.textContent = paramDef.label;
                field.appendChild(label);

                let input;
                // Helper to add Enter key handler
                const addEnterHandler = (el) => {
                    el.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            el.blur(); // Trigger change event
                            closeConfigPanel();
                        }
                    });
                };

                if (paramDef.type === 'checkbox') {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.checked = comp.params[key];
                    input.addEventListener('change', () => {
                        comp.params[key] = input.checked;
                    });
                } else if (paramDef.type === 'text') {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.value = comp.params[key];
                    input.addEventListener('change', () => {
                        comp.params[key] = input.value;
                    });
                    addEnterHandler(input);
                } else if (paramDef.type === 'phase') {
                    // Phase input - accepts expressions like pi, pi/2, 3/4pi
                    input = document.createElement('input');
                    input.type = 'text';
                    input.value = formatPhaseValue(comp.params[key]);
                    input.placeholder = 'e.g., pi, pi/2, 3/4pi';
                    input.style.fontFamily = 'inherit';
                    input.addEventListener('change', () => {
                        const parsed = parsePhaseExpression(input.value);
                        comp.params[key] = parsed;
                        input.value = formatPhaseValue(parsed);
                    });
                    addEnterHandler(input);
                } else if (paramDef.type === 'select') {
                    // Dropdown select
                    input = document.createElement('select');
                    for (const opt of paramDef.options) {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        if (comp.params[key] === opt) option.selected = true;
                        input.appendChild(option);
                    }
                    input.addEventListener('change', () => {
                        comp.params[key] = input.value;
                    });
                } else {
                    input = document.createElement('input');
                    input.type = 'number';
                    input.value = comp.params[key];
                    input.min = paramDef.min;
                    input.max = paramDef.max;
                    input.step = paramDef.step;
                    input.addEventListener('change', () => {
                        comp.params[key] = parseFloat(input.value);
                        // Update power fraction display for coupler
                        if (comp.type === 'coupler' && key === 'split') {
                            updateCouplerPowerFraction(comp.params.split);
                        }
                    });
                    addEnterHandler(input);
                }

                field.appendChild(input);
                fields.appendChild(field);
            }

            // Add power fraction display for coupler
            if (comp.type === 'coupler') {
                const infoDiv = document.createElement('div');
                infoDiv.id = 'coupler-power-info';
                infoDiv.style.cssText = 'font-size: 0.75rem; margin-top: 10px;';
                fields.appendChild(infoDiv);
                updateCouplerPowerFraction(comp.params.split);
            }

            // Position panel near component (viewport coordinates for position:fixed)
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            const scale = getCanvasScale();  // SVG to screen
            const padding = GameState.canvasPadding || 0;

            // Calculate viewport position (add padding offset)
            const compViewportX = rect.left + (comp.x * GameState.cellSize + padding) * scale;
            const compViewportY = rect.top + (comp.y * GameState.cellSize + padding) * scale;
            const compScreenWidth = def.width * GameState.cellSize * scale;

            panel.style.left = (compViewportX + compScreenWidth + 10) + 'px';
            panel.style.top = compViewportY + 'px';
            panel.classList.add('visible');
        }

        function updateCouplerPowerFraction(split) {
            const infoDiv = document.getElementById('coupler-power-info');
            if (!infoDiv) return;

            const crossPower = split * 100;
            const throughPower = (1 - split) * 100;
            const crossDb = split > 0 ? (10 * Math.log10(split)).toFixed(1) : '-∞';
            const throughDb = (1 - split) > 0 ? (10 * Math.log10(1 - split)).toFixed(1) : '-∞';

            infoDiv.innerHTML = `
                <div style="margin-bottom: 6px; color: var(--text-secondary);">Power distribution:</div>
                <div style="display: flex; margin-bottom: 3px;">
                    <span style="color: var(--text-secondary); width: 70px;">Cross:</span>
                    <span style="color: var(--text-primary);">${crossPower.toFixed(1)}% (${crossDb} dB)</span>
                </div>
                <div style="display: flex; margin-bottom: 3px;">
                    <span style="color: var(--text-secondary); width: 70px;">Through:</span>
                    <span style="color: var(--text-primary);">${throughPower.toFixed(1)}% (${throughDb} dB)</span>
                </div>
                <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 6px;">
                    Cross: in1↔out2, in2↔out1<br>
                    Through: in1→out1, in2→out2
                </div>
            `;
        }

        function closeConfigPanel() {
            document.getElementById('config-panel').classList.remove('visible');
            GameState.selectedComponent = null;
            renderComponents();
        }

        function deleteSelectedComponent() {
            if (GameState.selectedComponent) {
                saveState();

                // Remove connections
                GameState.connections = GameState.connections.filter(c =>
                    c.from.componentId !== GameState.selectedComponent &&
                    c.to.componentId !== GameState.selectedComponent
                );

                // Remove component
                GameState.components = GameState.components.filter(c => c.id !== GameState.selectedComponent);

                closeConfigPanel();
                renderComponents();
                renderConnections();
                updateStatus('Component deleted');
            }
        }

        // Helper function to create component SVG visual
        function createComponentSvg(type, width, height) {
            const def = ComponentTypes[type];
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.style.display = 'block';

            if (type === 'ring') {
                // Ring: circle with bus
                const topBusY = height * 0.25;
                const busGap = 2;
                const ringRadius = (height * 0.25) - busGap;

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', width / 2);
                circle.setAttribute('cy', height / 2);
                circle.setAttribute('r', ringRadius);
                circle.setAttribute('fill', 'transparent');
                circle.setAttribute('stroke', def.color);
                circle.setAttribute('stroke-width', '2');
                svg.appendChild(circle);

                const bus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                bus.setAttribute('x1', 2);
                bus.setAttribute('y1', topBusY);
                bus.setAttribute('x2', width - 2);
                bus.setAttribute('y2', topBusY);
                bus.setAttribute('stroke', def.color);
                bus.setAttribute('stroke-width', '2');
                svg.appendChild(bus);
            } else {
                // Rectangle for other components
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', 2);
                rect.setAttribute('y', 2);
                rect.setAttribute('width', width - 4);
                rect.setAttribute('height', height - 4);
                rect.setAttribute('rx', 3);
                rect.setAttribute('fill', def.color);
                rect.setAttribute('fill-opacity', '0.3');
                rect.setAttribute('stroke', def.color);
                rect.setAttribute('stroke-width', '2');
                svg.appendChild(rect);

                // Symbol - use Orbitron font to match board components
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', width / 2);
                text.setAttribute('y', height / 2);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('fill', 'white');
                text.setAttribute('font-family', "'Orbitron', sans-serif");
                text.setAttribute('font-weight', '600');
                text.setAttribute('font-size', '12');
                text.textContent = def.symbol;
                svg.appendChild(text);
            }

            return svg;
        }

        function initPalette() {
            const palette = document.getElementById('palette-items');
            const puzzle = Puzzles[GameState.currentPuzzleIndex];

            palette.innerHTML = '';

            const unitSize = 16; // pixels per grid unit in palette preview
            // Find max dimensions for uniform sizing
            const maxWidth = Math.max(...Object.values(ComponentTypes).map(d => d.width));
            const maxHeight = Math.max(...Object.values(ComponentTypes).map(d => d.height));
            const containerWidth = maxWidth * unitSize + 8;
            const containerHeight = maxHeight * unitSize + 8;

            for (const [type, def] of Object.entries(ComponentTypes)) {
                const item = document.createElement('div');
                item.className = 'palette-item';
                item.dataset.type = type;
                item.style.display = 'flex';
                item.style.flexDirection = 'column';
                item.style.alignItems = 'center';

                // Create container for SVG with fixed size
                const svgContainer = document.createElement('div');
                svgContainer.style.cssText = `
                    width: ${containerWidth}px;
                    height: ${containerHeight}px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin-bottom: 4px;
                `;

                // Create SVG for actual component size using helper
                const svgWidth = def.width * unitSize + 4;
                const svgHeight = def.height * unitSize + 4;
                const svg = createComponentSvg(type, svgWidth, svgHeight);

                svgContainer.appendChild(svg);
                item.appendChild(svgContainer);

                // Name and size label - use Orbitron font to match board components
                const label = document.createElement('div');
                label.style.fontFamily = "'Orbitron', sans-serif";
                label.style.fontSize = '0.65rem';
                label.style.fontWeight = '600';
                label.style.textAlign = 'center';
                label.innerHTML = `${def.name}<br><span style="color: var(--text-secondary); font-size: 0.55rem; font-weight: 500;">${def.width}×${def.height}</span>`;
                item.appendChild(label);

                // Click to select
                item.addEventListener('click', () => selectPaletteItem(type));

                // Drag from palette
                item.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    GameState.paletteDragging = {
                        type,
                        startX: e.clientX,
                        startY: e.clientY
                    };
                    selectPaletteItem(type);
                });

                palette.appendChild(item);
            }
        }

        // Global mouse handlers for palette dragging
        document.addEventListener('mousemove', (e) => {
            if (!GameState.paletteDragging) return;

            const dragGhost = document.getElementById('drag-ghost') || createDragGhost();
            const def = ComponentTypes[GameState.paletteDragging.type];
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            const scale = getCanvasScale();  // SVG to screen
            const svgScale = 1 / scale;  // screen to SVG
            const ghostWidth = def.width * GameState.cellSize * scale;
            const ghostHeight = def.height * GameState.cellSize * scale;

            // Check if mouse is over the canvas - if so, snap to grid
            const insideCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                                e.clientY >= rect.top && e.clientY <= rect.bottom;

            if (insideCanvas) {
                // Snap to grid (account for padding)
                const padding = GameState.canvasPadding || 0;
                const gridX = Math.floor(((e.clientX - rect.left) * svgScale - padding) / GameState.cellSize);
                const gridY = Math.floor(((e.clientY - rect.top) * svgScale - padding) / GameState.cellSize);

                // Convert back to screen coordinates (add padding back)
                const snapX = rect.left + (gridX * GameState.cellSize + padding) * scale;
                const snapY = rect.top + (gridY * GameState.cellSize + padding) * scale;

                dragGhost.style.left = snapX + 'px';
                dragGhost.style.top = snapY + 'px';
                dragGhost.style.opacity = '0.8';
            } else {
                // Free movement outside canvas
                dragGhost.style.left = e.clientX + 'px';
                dragGhost.style.top = e.clientY + 'px';
                dragGhost.style.opacity = '0.6';
            }

            dragGhost.style.display = 'block';
            dragGhost.style.width = ghostWidth + 'px';
            dragGhost.style.height = ghostHeight + 'px';

            // Update ghost content with SVG
            dragGhost.innerHTML = '';
            const svg = createComponentSvg(GameState.paletteDragging.type, ghostWidth, ghostHeight);
            dragGhost.appendChild(svg);
        });

        document.addEventListener('mouseup', (e) => {
            if (!GameState.paletteDragging) return;

            const dragGhost = document.getElementById('drag-ghost');
            if (dragGhost) dragGhost.style.display = 'none';

            // Check if dropped on canvas
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();

            if (e.clientX >= rect.left && e.clientX <= rect.right &&
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
                const svgScale = 1 / getCanvasScale();  // screen to SVG
                const padding = GameState.canvasPadding || 0;
                // Calculate position - snapped to grid (account for padding)
                const x = Math.floor(((e.clientX - rect.left) * svgScale - padding) / GameState.cellSize);
                const y = Math.floor(((e.clientY - rect.top) * svgScale - padding) / GameState.cellSize);
                placeComponent(GameState.paletteDragging.type, x, y);
            }

            GameState.paletteDragging = null;
        });

        function createDragGhost() {
            const ghost = document.createElement('div');
            ghost.id = 'drag-ghost';
            ghost.style.cssText = `
                position: fixed;
                box-sizing: border-box;
                display: none;
                pointer-events: none;
                z-index: 10000;
            `;
            document.body.appendChild(ghost);
            return ghost;
        }

        function selectPaletteItem(type) {
            GameState.selectedPaletteItem = type;

            document.querySelectorAll('.palette-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.type === type);
            });

            updateStatus(`Selected ${ComponentTypes[type].name} - click grid to place`);
        }

        function loadPuzzle(index) {
            const puzzle = Puzzles[index];
            GameState.currentPuzzleIndex = index;

            // Update UI
            document.getElementById('arc-name').textContent = puzzle.arc;
            document.getElementById('puzzle-progress').textContent = `Puzzle ${index + 1}/${Puzzles.length}`;
            document.getElementById('contract-title').textContent = puzzle.name;
            document.getElementById('contract-client').textContent = `Client: ${puzzle.client}`;
            document.getElementById('contract-description').innerHTML = puzzle.description.replace(/\n/g, '<br>');
            document.getElementById('contract-objective').textContent = puzzle.objective;
            document.getElementById('script-editor').value = puzzle.starterCode;

            // Hints
            const hintsList = document.getElementById('hints-list');
            hintsList.innerHTML = puzzle.hints.map(h => `<div class="hint-item">${h}</div>`).join('');
            hintsList.classList.add('hidden');

            // Reset circuit
            GameState.components = [];
            GameState.connections = [];
            GameState.selectedComponent = null;
            GameState.selectedComponents.clear();
            GameState.selectedPaletteItem = null;

            initCanvas();
            initPalette();
            renderComponents();
            renderConnections();
            closeResults();
            updateStatus('Puzzle loaded: ' + puzzle.name);
        }

        function resetCircuit() {
            const puzzle = Puzzles[GameState.currentPuzzleIndex];
            GameState.components = [];
            GameState.connections = [];
            GameState.selectedComponents.clear();
            GameState.selectedComponent = null;
            document.getElementById('script-editor').value = puzzle.starterCode;
            renderComponents();
            renderConnections();
            closeConfigPanel();
            closeResults();
            updateStatus('Circuit reset');
        }

        function toggleHints() {
            document.getElementById('hints-list').classList.toggle('hidden');
        }

        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        // ============================================
        // SIMULATION RUNNER
        // ============================================
        let consoleLog = [];
        let plotData = null;

        function runSimulation() {
            updateStatus('Running simulation...');

            const puzzle = Puzzles[GameState.currentPuzzleIndex];
            const code = document.getElementById('script-editor').value;

            consoleLog = [];
            plotData = null;
            instrumentState = { lasers: {}, detectors: {}, dacs: {} };

            // Check if there are any components placed
            if (GameState.components.length === 0) {
                consoleLog.push('ERROR: No components placed on the grid!');
                consoleLog.push('Place components and connect them before running.');
                showResults(false, [{
                    name: 'Setup Check',
                    passed: false,
                    error: 'No components placed. Place components and connect them first.',
                    checks: []
                }]);
                updateStatus('Failed - no components');
                return;
            }

            let allPassed = true;
            const results = [];

            for (const testCase of puzzle.testCases) {
                currentTestConditions = testCase.conditions;

                try {
                    // Create sandbox with instrument API
                    const rm = ResourceManager;
                    const condition = testCase.conditions;

                    // Phase shifter helper
                    const setPhaseShifter = (phase) => {
                        const shifters = GameState.components.filter(c => c.type === 'phase_shifter');
                        for (const s of shifters) {
                            s.params.delta_phi = phase;
                        }
                    };

                    const consoleMock = {
                        log: (...args) => consoleLog.push(args.join(' '))
                    };

                    // Plot function for scripts
                    const plot = (xData, yData, options = {}) => {
                        plotData = {
                            x: xData,
                            y: yData,
                            xlabel: options.xlabel || 'X',
                            ylabel: options.ylabel || 'Y',
                            title: options.title || 'Plot'
                        };
                    };

                    // Execute script
                    consoleLog.push('--- Running test: ' + testCase.name + ' ---');
                    const scriptFn = new Function('rm', 'condition', 'console', 'setPhaseShifter', 'parseFloat', 'plot', code);
                    const scriptResult = scriptFn(rm, condition, consoleMock, setPhaseShifter, parseFloat, plot);

                    if (!scriptResult || typeof scriptResult !== 'object') {
                        throw new Error('Script must return an object with measurement results');
                    }

                    // Check results
                    const testResult = { name: testCase.name, passed: true, checks: [] };

                    for (const [key, expected] of Object.entries(testCase.expected)) {
                        const actual = scriptResult[key];
                        let passed = false;

                        if (expected.comparison === 'equals') {
                            passed = Math.abs(actual - expected.value) <= (expected.tolerance || 0.5);
                        } else if (expected.comparison === 'greater') {
                            passed = actual > expected.value;
                        } else if (expected.comparison === 'less') {
                            passed = actual < expected.value;
                        }

                        let actualStr = 'undefined';
                        if (actual !== undefined && actual !== null) {
                            if (isNaN(actual) || !isFinite(actual)) {
                                actualStr = 'No signal (check waveguides)';
                                passed = false;
                            } else {
                                actualStr = actual.toFixed(2) + ' ' + (expected.unit || '');
                            }
                        }

                        testResult.checks.push({
                            name: key,
                            expected: formatExpected(expected),
                            actual: actualStr,
                            passed
                        });

                        if (!passed) {
                            testResult.passed = false;
                            allPassed = false;
                        }
                    }

                    results.push(testResult);

                } catch (err) {
                    consoleLog.push('ERROR: ' + err.message);
                    results.push({
                        name: testCase.name,
                        passed: false,
                        error: err.message,
                        checks: []
                    });
                    allPassed = false;
                }
            }

            showResults(allPassed, results);

            if (allPassed) {
                GameState.completedPuzzles.add(puzzle.id);
                updateStatus('All tests passed!');
            } else {
                updateStatus('Tests failed - check results');
            }
        }

        function renderPlot(data) {
            const width = 350;
            const height = 200;
            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const xMin = Math.min(...data.x);
            const xMax = Math.max(...data.x);
            const yMin = Math.min(...data.y);
            const yMax = Math.max(...data.y);

            const xRange = xMax - xMin || 1;
            const yRange = yMax - yMin || 1;

            const scaleX = (x) => margin.left + ((x - xMin) / xRange) * plotWidth;
            const scaleY = (y) => margin.top + plotHeight - ((y - yMin) / yRange) * plotHeight;

            // Build path
            const points = data.x.map((x, i) => `${scaleX(x)},${scaleY(data.y[i])}`).join(' ');

            // Generate grid lines and labels
            const numXTicks = 5;
            const numYTicks = 5;
            let gridLines = '';
            let axisLabels = '';

            for (let i = 0; i <= numXTicks; i++) {
                const xVal = xMin + (i / numXTicks) * xRange;
                const xPos = scaleX(xVal);
                gridLines += `<line class="plot-grid-line" x1="${xPos}" y1="${margin.top}" x2="${xPos}" y2="${margin.top + plotHeight}"/>`;
                axisLabels += `<text class="plot-axis-label" x="${xPos}" y="${height - 5}" text-anchor="middle">${xVal.toFixed(1)}</text>`;
            }

            for (let i = 0; i <= numYTicks; i++) {
                const yVal = yMin + (i / numYTicks) * yRange;
                const yPos = scaleY(yVal);
                gridLines += `<line class="plot-grid-line" x1="${margin.left}" y1="${yPos}" x2="${margin.left + plotWidth}" y2="${yPos}"/>`;
                axisLabels += `<text class="plot-axis-label" x="${margin.left - 5}" y="${yPos + 3}" text-anchor="end">${yVal.toFixed(1)}</text>`;
            }

            return `
                <div class="plot-title">${data.title}</div>
                <svg class="plot-svg" width="${width}" height="${height}">
                    ${gridLines}
                    <line class="plot-axis" x1="${margin.left}" y1="${margin.top + plotHeight}" x2="${margin.left + plotWidth}" y2="${margin.top + plotHeight}"/>
                    <line class="plot-axis" x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotHeight}"/>
                    <polyline class="plot-line" points="${points}"/>
                    ${axisLabels}
                    <text class="plot-axis-label" x="${width / 2}" y="${height - 2}" text-anchor="middle">${data.xlabel}</text>
                    <text class="plot-axis-label" x="12" y="${height / 2}" text-anchor="middle" transform="rotate(-90 12 ${height / 2})">${data.ylabel}</text>
                </svg>
            `;
        }

        function formatExpected(expected) {
            if (expected.comparison === 'equals') {
                return `${expected.value} ± ${expected.tolerance || 0.5} ${expected.unit}`;
            } else if (expected.comparison === 'greater') {
                return `> ${expected.value} ${expected.unit}`;
            } else if (expected.comparison === 'less') {
                return `< ${expected.value} ${expected.unit}`;
            }
            return String(expected.value);
        }

        function showResults(allPassed, results) {
            const panel = document.getElementById('results-panel');
            const title = document.getElementById('results-title');
            const content = document.getElementById('results-content');
            const consoleDiv = document.getElementById('console-output');

            title.textContent = allPassed ? 'ALL TESTS PASSED!' : 'TESTS FAILED';
            title.className = 'results-title ' + (allPassed ? 'pass' : 'fail');

            content.innerHTML = results.map(r => `
                <div class="test-case">
                    <div class="test-case-header">
                        <span class="test-case-name">${r.name}</span>
                        <span class="test-case-status ${r.passed ? 'pass' : 'fail'}">${r.passed ? '✓ PASS' : '✗ FAIL'}</span>
                    </div>
                    ${r.error ? `<div class="test-case-details" style="color: var(--accent-red)">Error: ${r.error}</div>` : ''}
                    ${r.checks.map(c => `
                        <div class="test-case-details">
                            <span>${c.name}:</span>
                            <span class="expected-value">Expected: ${c.expected}</span>
                            <span class="actual-value ${c.passed ? 'pass' : 'fail'}">Actual: ${c.actual}</span>
                        </div>
                    `).join('')}
                </div>
            `).join('');

            consoleDiv.innerHTML = consoleLog.map(line =>
                `<div class="console-line">${line}</div>`
            ).join('');

            // Render plot if available
            const plotContainer = document.getElementById('plot-container');
            if (plotData && plotData.x && plotData.y && plotData.x.length > 0) {
                plotContainer.style.display = 'block';
                plotContainer.innerHTML = renderPlot(plotData);
            } else {
                plotContainer.style.display = 'none';
            }

            document.getElementById('score-components').textContent = GameState.components.length;
            document.getElementById('score-connections').textContent = GameState.connections.length;

            document.getElementById('next-puzzle-btn').style.display =
                allPassed && GameState.currentPuzzleIndex < Puzzles.length - 1 ? 'inline-block' : 'none';

            panel.classList.add('visible');
            document.getElementById('results-overlay').classList.add('visible');
        }

        function closeResults() {
            document.getElementById('results-panel').classList.remove('visible');
            document.getElementById('results-overlay').classList.remove('visible');
        }

        function nextPuzzle() {
            if (GameState.currentPuzzleIndex < Puzzles.length - 1) {
                loadPuzzle(GameState.currentPuzzleIndex + 1);
            }
        }

        function showPuzzleSelector() {
            const list = document.getElementById('puzzle-list');
            list.innerHTML = Puzzles.map((p, i) => `
                <div class="puzzle-item ${GameState.completedPuzzles.has(p.id) ? 'completed' : ''} ${i === GameState.currentPuzzleIndex ? 'current' : ''}"
                     onclick="selectPuzzle(${i})">
                    <div class="puzzle-item-title">${i + 1}. ${p.name}</div>
                    <div class="puzzle-item-arc">${p.arc}</div>
                </div>
            `).join('');

            document.getElementById('puzzle-modal').classList.remove('hidden');
        }

        function hidePuzzleSelector() {
            document.getElementById('puzzle-modal').classList.add('hidden');
        }

        function selectPuzzle(index) {
            loadPuzzle(index);
            hidePuzzleSelector();
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        window.addEventListener('load', () => {
            initCanvas();
            loadPuzzle(0);

            // Add drag event listeners
            const canvas = document.getElementById('game-canvas');
            // Use document-level handlers for component dragging to work outside canvas
            document.addEventListener('mousemove', handleCanvasMouseMove);
            document.addEventListener('mouseup', handleCanvasMouseUp);
        });

        window.addEventListener('resize', () => {
            initCanvas();
            renderComponents();
            renderConnections();
        });

        // Close config panel when clicking outside
        document.addEventListener('click', (e) => {
            const configPanel = document.getElementById('config-panel');
            if (configPanel.classList.contains('visible') &&
                !configPanel.contains(e.target) &&
                !e.target.closest('.component')) {
                closeConfigPanel();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Undo: Ctrl+Z
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
                return;
            }
            // Redo: Ctrl+Y or Ctrl+Shift+Z
            if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
                e.preventDefault();
                redo();
                return;
            }
            if (e.key === 'Escape') {
                GameState.selectedPaletteItem = null;
                GameState.connectingFrom = null;
                GameState.connectionDragging = null;
                GameState.paletteDragging = null;
                GameState.boxSelect = null;
                GameState.selectedComponents.clear();
                document.querySelectorAll('.palette-item').forEach(i => i.classList.remove('selected'));
                document.getElementById('preview').innerHTML = '';
                renderSelectionRect();
                closeConfigPanel();
                closeResults();
                hidePuzzleSelector();
                renderComponents();
                updateStatus('Selection cancelled');
            } else if (e.key === 'Delete') {
                // Delete selected components (single or multi)
                if (GameState.selectedComponents.size > 0) {
                    saveState();
                    for (const compId of GameState.selectedComponents) {
                        GameState.connections = GameState.connections.filter(c =>
                            c.from.componentId !== compId && c.to.componentId !== compId
                        );
                        GameState.components = GameState.components.filter(c => c.id !== compId);
                    }
                    GameState.selectedComponents.clear();
                    closeConfigPanel();
                    renderComponents();
                    renderConnections();
                    updateStatus('Components deleted');
                } else if (GameState.selectedComponent) {
                    deleteSelectedComponent();
                }
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Arrow key scrolling when no component is selected and not in script editor
                const activeEl = document.activeElement;
                const isInEditor = activeEl && (activeEl.id === 'script-editor' || activeEl.tagName === 'INPUT');
                const hasSelection = GameState.selectedComponent || GameState.selectedComponents.size > 0;

                if (!isInEditor && !hasSelection) {
                    e.preventDefault();
                    const container = document.querySelector('.canvas-container');
                    const scrollAmount = GameState.cellSize; // Scroll by one cell

                    switch (e.key) {
                        case 'ArrowUp':
                            container.scrollTop -= scrollAmount;
                            break;
                        case 'ArrowDown':
                            container.scrollTop += scrollAmount;
                            break;
                        case 'ArrowLeft':
                            container.scrollLeft -= scrollAmount;
                            break;
                        case 'ArrowRight':
                            container.scrollLeft += scrollAmount;
                            break;
                    }
                }
            }
        });

        // ============================================
        // RESIZE HANDLE
        // ============================================
        (function() {
            const handle = document.getElementById('resize-handle');
            const rightPanel = document.getElementById('right-panel');
            let isResizing = false;
            let startX, startWidth;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = rightPanel.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const diff = startX - e.clientX;
                const newWidth = Math.min(Math.max(startWidth + diff, 300), 700);
                rightPanel.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    // Reinitialize canvas after resize
                    initCanvas();
                    renderComponents();
                    renderConnections();
                }
            });
        })();
    </script>
</body>
</html>
